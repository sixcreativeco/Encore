import Foundation
import FirebaseFirestore
import FirebaseAuth
import Combine

class AppState: ObservableObject {
    @Published var userID: String? = nil
    @Published var selectedTab: String = "Dashboard"
    
    // FIX: State properties now use the new 'Tour' and 'Show' models.
    @Published var selectedTour: Tour? = nil
    @Published var selectedShow: Show? = nil
    @Published var tours: [Tour] = []

    private var authStateHandle: AuthStateDidChangeListenerHandle?
    
    init() {
        registerAuthStateHandler()
    }

    deinit {
        if let authStateHandle = authStateHandle {
            Auth.auth().removeStateDidChangeListener(authStateHandle)
        }
    }

    private func registerAuthStateHandler() {
        authStateHandle = Auth.auth().addStateDidChangeListener { [weak self] (_, user) in
            self?.objectWillChange.send()
            
            DispatchQueue.main.async {
                self?.userID = user?.uid
                if user == nil {
                    // Clear all data on sign out
                    self?.tours.removeAll()
                    self?.selectedTour = nil
                    self?.selectedShow = nil
                } else {
                    // Load data on sign in
                    self?.loadTours()
                }
            }
        }
    }
 
    func removeTour(tourID: String) {
        if let index = tours.firstIndex(where: { $0.id == tourID }) {
            tours.remove(at: index)
        }
    }

    // FIX: Rewritten to use the new flat structure and be more efficient.
    func loadTours() {
        guard let userID = userID else { return }
        let db = Firestore.firestore()
        var allTours: [Tour] = []
        let group = DispatchGroup()

        // 1. Fetch tours the user owns
        group.enter()
        db.collection("tours")
            .whereField("ownerId", isEqualTo: userID)
            .getDocuments { snapshot, _ in
                let ownedTours = snapshot?.documents.compactMap { try? $0.data(as: Tour.self) } ?? []
                allTours.append(contentsOf: ownedTours)
                group.leave()
            }

        // 2. Fetch tours that have been shared with the user
        group.enter()
        db.collection("users").document(userID).collection("sharedTours").getDocuments { snapshot, _ in
            guard let documents = snapshot?.documents, !documents.isEmpty else {
                group.leave()
                return
            }
            
            let tourIDs = documents.map { $0.documentID }
            
            // Fetch all shared tours in a single efficient query
            db.collection("tours").whereField(FieldPath.documentID(), in: tourIDs)
                .getDocuments { tourSnapshot, _ in
                    let sharedTours = tourSnapshot?.documents.compactMap { try? $0.data(as: Tour.self) } ?? []
                    allTours.append(contentsOf: sharedTours)
                    group.leave()
                }
        }

        // 3. Once all fetching is complete, update the main tours array.
        group.notify(queue: .main) {
            // Sort all tours together by start date
            self.tours = allTours.sorted(by: { $0.startDate.dateValue() < $1.startDate.dateValue() })
        }
    }
}
import Foundation

enum HotelFilter: String, CaseIterable {
    case all = "All"
    case Auckland
    case Wellington
    case Christchurch
    case Other

    var displayName: String {
        switch self {
        case .all: return "All"
        case .Auckland: return "Auckland"
        case .Wellington: return "Wellington"
        case .Christchurch: return "Christchurch"
        case .Other: return "Other"
        }
    }
}
import Foundation
import Network
import Firebase

class OfflineSyncManager: ObservableObject {
    static let shared = OfflineSyncManager()

    @Published var isOnline: Bool = false

    private let monitor = NWPathMonitor()
    private let queue = DispatchQueue(label: "NetworkMonitor")

    private init() {
        startNetworkMonitoring()
    }

    private func startNetworkMonitoring() {
        monitor.pathUpdateHandler = { path in
            DispatchQueue.main.async {
                self.isOnline = (path.status == .satisfied)
            }
        }
        monitor.start(queue: queue)
    }
}
import Foundation

struct PassengerEntry: Identifiable, Codable {
    var id: String = UUID().uuidString
    var name: String
    var baggage: String
}
import SwiftUI

struct AirportSelectorComponent: View {
    @Binding var selectedAirport: AirportEntry?

    @State private var searchText: String = ""
    @State private var isDropdownVisible = false

    private let airports = AirportService.shared.airports

    private var filteredAirports: [AirportEntry] {
        if searchText.isEmpty { return [] }
        return airports.filter {
            $0.name.lowercased().contains(searchText.lowercased()) ||
            $0.city.lowercased().contains(searchText.lowercased()) ||
            $0.iata.lowercased().contains(searchText.lowercased())
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Departure Airport").font(.subheadline)

            ZStack(alignment: .top) {
                VStack(spacing: 0) {
                    TextField("Start typing airport or city...", text: $searchText, onEditingChanged: { editing in
                        isDropdownVisible = editing
                    })
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .onChange(of: searchText) { _ in
                        isDropdownVisible = true
                        selectedAirport = nil
                    }

                    if isDropdownVisible && !filteredAirports.isEmpty {
                        ScrollView {
                            VStack(alignment: .leading, spacing: 0) {
                                ForEach(filteredAirports) { airport in
                                    Button(action: {
                                        selectAirport(airport)
                                    }) {
                                        HStack {
                                            Text("\(airport.name) (\(airport.iata))")
                                            Spacer()
                                        }
                                        .padding(.vertical, 8)
                                        .padding(.horizontal, 4)
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                }
                            }
                        }
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                        .frame(maxHeight: 200)
                    }
                }
            }

            if let selected = selectedAirport {
                Text("Selected: \(selected.name)").font(.caption).foregroundColor(.gray)
            }
        }
    }

    private func selectAirport(_ airport: AirportEntry) {
        selectedAirport = airport
        searchText = "\(airport.name) (\(airport.iata))"
        isDropdownVisible = false
    }
}
import SwiftUI

struct FlightItemCard: View {
    // FIX: Changed from FlightModel to our new Flight struct.
    let flight: Flight
    let isExpanded: Bool
    let onExpandToggle: () -> Void
    let onEdit: () -> Void
    let onDelete: () -> Void

    private let editColor = Color(red: 116/255, green: 151/255, blue: 173/255)
    private let deleteColor = Color(red: 193/255, green: 106/255, blue: 106/255)

    var body: some View {
        // NOTE: All UI code below is identical to your original file.
        VStack(spacing: 0) {
            VStack(alignment: .leading, spacing: 12) {
                HStack(alignment: .top) {
                    VStack(alignment: .leading, spacing: 4) {
                        // FIX: Using optional-safe access for new model properties
                        Text("\(flight.airline ?? "N/A") - \(flight.flightNumber ?? "----")")
                            .font(.caption)
                            .foregroundColor(isAirNZ ? .white : .gray)

                        // FIX: Using new property names 'origin' and 'destination'
                        Text("\(flight.origin) - \(flight.destination)")
                            .font(.system(size: 32, weight: .bold))
                            .foregroundColor(isAirNZ ? .white : .black)

                        HStack(spacing: 16) {
                            HStack(spacing: 8) {
                                Image(systemName: "airplane.departure")
                                    .font(.caption)
                                    .foregroundColor(isAirNZ ? .white : .gray)
                                // FIX: Accessing .dateValue() from the Timestamp property
                                Text("\(formattedTime(flight.departureTimeUTC.dateValue()))")
                                    .font(.caption)
                                    .foregroundColor(isAirNZ ? .white : .gray)
                            }

                            HStack(spacing: 8) {
                                Image(systemName: "airplane.arrival")
                                    .font(.caption)
                                    .foregroundColor(isAirNZ ? .white : .gray)
                                // FIX: Accessing .dateValue() from the Timestamp property
                                Text("\(formattedArrivalTime(flight.arrivalTimeUTC.dateValue()))")
                                    .font(.caption)
                                    .foregroundColor(isAirNZ ? .white : .gray)
                            }
                        }
                    }

                    Spacer()
                    
                    // This logic remains the same, but is now safer with nil-coalescing
                    let airlineCode = extractAirlineCode(from: flight.flightNumber ?? "")
                    let imageName = airlineCode.uppercased() == "NZ" ? "\(airlineCode)_icon_light" : "\(airlineCode)_icon"

                    Image(imageName)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 60, height: 60)
                }
            }
            .padding()
            .onTapGesture {
                onExpandToggle()
            }

            if isExpanded {
                VStack(spacing: 16) {
                    HStack(spacing: 24) {
                        Button(action: { onEdit() }) {
                            Text("Edit")
                                .fontWeight(.semibold)
                                .padding(.vertical, 10)
                                .frame(maxWidth: .infinity)
                                .foregroundColor(.white)
                                .background(editColor)
                                .cornerRadius(12)
                        }
                        .buttonStyle(.plain)

                        Button(action: { onDelete() }) {
                            Text("Delete")
                                .fontWeight(.semibold)
                                .padding(.vertical, 10)
                                .frame(maxWidth: .infinity)
                                .foregroundColor(.white)
                                .background(deleteColor)
                                .cornerRadius(12)
                        }
                        .buttonStyle(.plain)
                    }
                    .padding(.horizontal)
                }
                .padding(.top, 16)
                .padding(.bottom, 12)
                .transition(.opacity)
            }
        }
        .background(isAirNZ ? Color(red: 20/255, green: 20/255, blue: 20/255) : Color.white)
        .cornerRadius(16)
        .shadow(color: Color.black.opacity(0.05), radius: 3)
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
    }

    private var isAirNZ: Bool {
        extractAirlineCode(from: flight.flightNumber ?? "").uppercased() == "NZ"
    }

    private func extractAirlineCode(from flightNumber: String) -> String {
        let prefix = flightNumber.prefix { $0.isLetter }
        return String(prefix)
    }

    private func formattedTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mma"
        return formatter.string(from: date).lowercased()
    }
    
    // NOTE: This logic seems to assume a 3-hour flight. You may want to revise this later.
    private func formattedArrivalTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mma"
        return formatter.string(from: date).lowercased()
    }
}
import Foundation

class AirportDataManager: ObservableObject {
    @Published var airports: AirportDictionary = [:]

    init() {
        loadAirports()
    }

    private func loadAirports() {
        guard let url = Bundle.main.url(forResource: "airports", withExtension: "json") else {
            print("❌ Could not find airports.json")
            return
        }

        do {
            let data = try Data(contentsOf: url)
            let decoder = JSONDecoder()
            self.airports = try decoder.decode(AirportDictionary.self, from: data)
            print("✅ Loaded \(airports.count) airports.")
        } catch {
            print("❌ Error loading airports: \(error)")
        }
    }
}
import Foundation

struct FlightLabsAPI {
    static let apiKey = "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiI0IiwianRpIjoiMGI3NzFlYTZhMTI1NWY4YmUwZGM1Yzk3YzE2Mzg3ODUyYjk0Y2ZlNGMxODkxOTJlZDg5ODkzZmUwNzU2NmQ4MmY2Y2ZkNDE1ZmQ0NzdhMWUiLCJpYXQiOjE3MzY3MjcxMDQsIm5iZiI6MTczNjcyNzEwNCwiZXhwIjoxNzY4MjYzMTA0LCJzdWIiOiIyNDA4NyIsInNjb3BlcyI6W119.FZPD2V2tOEyNJbA6NOFTKczQpCYxHzOwySctJ6JztbjxFc5BowV3StjVGE4knm-8oBVL7JmYojwe1nLMHlU3zg"
    static let baseURL = "https://www.goflightlabs.com/advanced-future-flights"

    static func fetchFutureFlights(depIATA: String, date: String, completion: @escaping (Result<[FlightLabsFlight], Error>) -> Void) {

        let urlString = "\(baseURL)?access_key=\(apiKey)&type=departure&iataCode=\(depIATA)&date=\(date)"
        print("📡 API Request URL: \(urlString)")

        guard let url = URL(string: urlString) else {
            print("❌ Invalid URL constructed.")
            completion(.failure(NSError(domain: "BadURL", code: 0)))
            return
        }

        URLSession.shared.dataTask(with: url) { data, response, error in

            if let error = error {
                print("❌ API request failed: \(error.localizedDescription)")
                completion(.failure(error))
                return
            }

            guard let data = data else {
                print("❌ No data returned from API.")
                completion(.failure(NSError(domain: "NoData", code: 0)))
                return
            }

            if let rawResponse = String(data: data, encoding: .utf8) {
                print("📄 Raw API Response: \(rawResponse)")
            }

            do {
                let decoded = try JSONDecoder().decode(FlightLabsResponse.self, from: data)
                print("✅ Successfully decoded response. Found \(decoded.data.count) flights.")
                completion(.success(decoded.data))
            } catch {
                print("❌ Decoding error: \(error)")
                completion(.failure(error))
            }
        }.resume()
    }
}

// MARK: - FlightLabs Models

struct FlightLabsResponse: Codable {
    let success: Bool
    let data: [FlightLabsFlight]
}

struct FlightLabsFlight: Codable {
    let sortTime: String
    let departureTime: FlightTime?
    let arrivalTime: FlightTime?
    let carrier: Carrier
    let operatedBy: String?
    let airport: DestinationAirport
}

struct FlightTime: Codable {
    let timeAMPM: String
    let time24: String
}

struct Carrier: Codable {
    let fs: String
    let name: String
    let flightNumber: String
}

struct DestinationAirport: Codable {
    let fs: String
    let city: String
}
import SwiftUI

// This file contains the SwiftUI Views that will be rendered as PDF pages.
struct ShowTimingPDFView: View {
    // FIX: Updated to use the new 'Show' and 'Tour' models.
    let show: Show
    let tour: Tour

    private var eventTimeFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a" // e.g., 4:30 PM
        return formatter
    }
    
    private var fullDateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .full // e.g., Tuesday, June 18, 2025
        return formatter
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header
            VStack(alignment: .leading) {
                // FIX: Using new property names
                Text("\(tour.artist) - \(tour.tourName)")
                    .font(.largeTitle.bold())
                Text("Show Day Sheet: \(show.city)")
                    .font(.title2)
                    .foregroundColor(.secondary)
                Divider()
            }

            // Info Grid
            HStack(alignment: .top) {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Date").font(.headline)
                    // FIX: Using .dateValue() on the Timestamp
                    Text(fullDateFormatter.string(from: show.date.dateValue()))
                }
                Spacer()
                VStack(alignment: .leading, spacing: 8) {
                    Text("Venue").font(.headline)
                    Text(show.venueName)
                    Text(show.venueAddress)
                }
                Spacer()
                VStack(alignment: .leading, spacing: 8) {
                    Text("Venue Contact").font(.headline)
                    Text(show.contactName ?? "N/A")
                    Text(show.contactPhone ?? "")
                }
            }
            .padding(.bottom)

            // Timeline
            VStack(alignment: .leading, spacing: 12) {
                Text("Schedule").font(.title.bold())
                // FIX: Using .dateValue() on Timestamps
                EventRow(title: "Venue Access", time: show.venueAccess?.dateValue())
                EventRow(title: "Load In", time: show.loadIn?.dateValue())
                
                // Note: Support Acts would need to be fetched separately based on the new schema.
                // For now, this part is commented out. We can add it back later.
                /*
                ForEach(show.supportActs) { act in
                    EventRow(title: "\(act.name) Soundcheck", time: act.soundCheck)
                    EventRow(title: "\(act.name) Set", time: act.setTime)
                }
                */
                
                EventRow(title: "Headliner Soundcheck", time: show.soundCheck?.dateValue())
                EventRow(title: "Doors Open", time: show.doorsOpen?.dateValue())
                EventRow(title: "Headliner Set", time: show.headlinerSetTime?.dateValue())
                EventRow(title: "Pack Out", time: show.packOut?.dateValue())
            }
            
            Spacer()
        }
        .padding(40)
        .frame(width: 595, height: 842) // A4 Paper size at 72 dpi
    }

    private func EventRow(title: String, time: Date?) -> some View {
      HStack {
            Text(time != nil ? eventTimeFormatter.string(from: time!) : "TBC")
                .font(.system(size: 14, weight: .bold))
                .frame(width: 100, alignment: .leading)
            Text(title)
                .font(.system(size: 14))
            Spacer()
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct ContactFormBody: View {
    // FIX: The view now accepts a binding to our new, top-level 'Contact' model.
    @Binding var contact: Contact
    var isDisabled: Bool

    // MARK: - State
    @State private var isTravelDetailsExpanded: Bool = true
    @State private var isEmergencyDetailsExpanded: Bool = true
    @State private var roleInput: String = ""
    
    // These local state variables are fine as they don't interact with the main model directly.
    @State private var homeAirport: String = ""
    @State private var loyaltyAirline: String = ""
    @State private var loyaltyMembership: String = ""

    private let roleOptions: [String] = [
        "Lead Artist", "Support Artist", "DJ", "Dancer", "Guest Performer", "Musician",
        "Content", "Tour Manager", "Artist Manager", "Road Manager", "Assistant Manager",
        "Tour Accountant", "Advance Coordinator", "Production Manager", "Stage Manager",
        "Lighting", "Sound", "Audio Tech", "Video", "Playback Operator", "Backline Tech",
        "Rigger", "SFX", "Driver", "Transport Coordinator", "Logistics", "Fly Tech",
        "Local Runner", "Security", "Assistant", "Stylist", "Hair and Makeup", "Catering",
        "Merch Manager", "Wellness", "PA", "Childcare", "Label Rep", "Marketing",
        "Street Team", "Promoter Rep", "Merch Staff", "Translator", "Drone Op",
        "Content Creator", "Custom"
    ]
    
    private var filteredRoles: [String] {
        guard !roleInput.isEmpty else { return [] }
        return roleOptions.filter {
            $0.lowercased().contains(roleInput.lowercased()) && !contact.roles.contains($0)
        }
    }

    // MARK: - Body
    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            headerSection
            rolesInputView

            HStack(alignment: .lastTextBaseline, spacing: 16) {
                // FIX: This binding helper now works with the new Timestamp property.
                CustomDateInputView(label: "Date of Birth", date: timestampBinding(for: $contact.dateOfBirth))
                VStack(alignment: .leading, spacing: 4) {
                    Text("Country of Birth").font(.subheadline).foregroundColor(.gray)
                    StyledInputField(placeholder: "Country of Birth", text: optionalStringBinding(for: $contact.countryOfBirth))
                }
            }

            CollapsibleSection(isExpanded: $isTravelDetailsExpanded, title: "Travel Details") {
                VStack(alignment: .leading, spacing: 16) {
                    // FIX: All passport bindings now correctly handle the optional PassportInfo struct.
                    StyledInputField(placeholder: "Passport Number", text: passportStringBinding(for: \.passportNumber))
                    HStack(spacing: 16) {
                        CustomDateInputView(label: "Issued Date", date: passportTimestampBinding(for: \.issuedDate))
                        CustomDateInputView(label: "Expiry Date", date: passportTimestampBinding(for: \.expiryDate))
                    }
                    StyledInputField(placeholder: "Issuing Country", text: passportStringBinding(for: \.issuingCountry))
                    StyledInputField(placeholder: "Home Airport", text: $homeAirport)

                    Text("Loyalty Program").font(.headline).padding(.top)
                    HStack(spacing: 16) {
                        StyledInputField(placeholder: "Type Airline", text: $loyaltyAirline)
                        StyledInputField(placeholder: "Enter Membership", text: $loyaltyMembership)
                    }
                    
                    Text("Documents").font(.headline).padding(.top)
                    Text("No documents uploaded.")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .padding()
                        .frame(maxWidth: .infinity, alignment: .center)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                }
            }

            CollapsibleSection(isExpanded: $isEmergencyDetailsExpanded, title: "Emergency Details") {
                VStack(spacing: 12) {
                    HStack(spacing: 16) {
                        StyledInputField(placeholder: "Emergency Contact", text: emergencyBinding(for: \.name))
                        StyledInputField(placeholder: "Phone Number", text: emergencyBinding(for: \.phone))
                    }
                    StyledInputField(placeholder: "Allergies", text: optionalStringBinding(for: $contact.allergies))
                    StyledInputField(placeholder: "Medications", text: optionalStringBinding(for: $contact.medications))
                }
            }
            .padding(.bottom)
        }
        .disabled(isDisabled)
    }
    
    private var headerSection: some View {
        HStack(alignment: .top, spacing: 24) {
            VStack(spacing: 12) {
                StyledInputField(placeholder: "Full Name*", text: $contact.name)
                StyledInputField(placeholder: "Location (e.g. Auckland, NZ)", text: optionalStringBinding(for: $contact.location))
                StyledInputField(placeholder: "Email", text: optionalStringBinding(for: $contact.email))
                StyledInputField(placeholder: "Phone Number", text: optionalStringBinding(for: $contact.phone))
            }
            
            Image(systemName: "person.crop.rectangle.fill")
                .font(.system(size: 100))
                .foregroundColor(.gray.opacity(0.5))
                .frame(width: 150)
                .background(Color.gray.opacity(0.1))
                .cornerRadius(16)
        }
    }
    
    private var rolesInputView: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text("Roles*").font(.subheadline).foregroundColor(.gray)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 6) {
                    ForEach(contact.roles, id: \.self) { role in
                        HStack(spacing: 6) {
                            Text(role).font(.subheadline)
                            Button(action: { contact.roles.removeAll { $0 == role } }) {
                                Image(systemName: "xmark").font(.system(size: 10, weight: .bold)).foregroundColor(.gray)
                            }.buttonStyle(.plain)
                        }
                        .padding(.horizontal, 8).padding(.vertical, 4).background(Color.gray.opacity(0.2)).cornerRadius(6)
                    }
                    
                    TextField("Add Role", text: $roleInput)
                        .textFieldStyle(PlainTextFieldStyle())
                        .frame(minWidth: 150)
                        .onSubmit(addCustomRole)
                }
                .padding(8)
            }
            .frame(height: 44).background(Color(nsColor: .controlBackgroundColor)).cornerRadius(8)

            if !filteredRoles.isEmpty {
                VStack(alignment: .leading, spacing: 0) {
                    ForEach(Array(filteredRoles.prefix(5).enumerated()), id: \.element) { index, suggestion in
                        Button(action: {
                            contact.roles.append(suggestion)
                            roleInput = ""
                        }) {
                            Text(suggestion)
                                .padding(8)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .buttonStyle(.plain)

                        if index < filteredRoles.prefix(5).count - 1 {
                            Divider()
                        }
                    }
                }
                .background(Color(nsColor: .windowBackgroundColor))
                .cornerRadius(8)
                .shadow(radius: 2)
            }
        }
    }
    
    private func addCustomRole() {
        let trimmedRole = roleInput.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedRole.isEmpty, !contact.roles.contains(trimmedRole) else {
            roleInput = ""
            return
        }
        contact.roles.append(trimmedRole)
        roleInput = ""
    }

    // MARK: - Bindings
    private func optionalStringBinding(for binding: Binding<String?>) -> Binding<String> {
        Binding<String>( get: { binding.wrappedValue ?? "" }, set: { binding.wrappedValue = $0.isEmpty ? nil : $0 } )
    }
    
    private func timestampBinding(for optionalTimestamp: Binding<Timestamp?>) -> Binding<Date> {
        Binding<Date>(
            get: { optionalTimestamp.wrappedValue?.dateValue() ?? Date() },
            set: { optionalTimestamp.wrappedValue = Timestamp(date: $0) }
        )
    }
    
    private func passportStringBinding(for keyPath: WritableKeyPath<PassportInfo, String>) -> Binding<String> {
        Binding<String>(
            get: { self.contact.passport?[keyPath: keyPath] ?? "" },
            set: { newValue in
                if self.contact.passport == nil {
                    self.contact.passport = PassportInfo(passportNumber: "", issuedDate: Timestamp(date: Date()), expiryDate: Timestamp(date: Date()), issuingCountry: "")
                }
                self.contact.passport?[keyPath: keyPath] = newValue
            }
        )
    }
    
    private func passportTimestampBinding(for keyPath: WritableKeyPath<PassportInfo, Timestamp>) -> Binding<Date> {
        Binding<Date>(
            get: {
                if let date = self.contact.passport?[keyPath: keyPath].dateValue() {
                    return date
                }
                return Date()
            },
            set: { newValue in
                if self.contact.passport == nil {
                    self.contact.passport = PassportInfo(passportNumber: "", issuedDate: Timestamp(date: Date()), expiryDate: Timestamp(date: Date()), issuingCountry: "")
                }
                self.contact.passport?[keyPath: keyPath] = Timestamp(date: newValue)
            }
        )
    }
    
    private func emergencyBinding(for keyPath: WritableKeyPath<EmergencyContact, String>) -> Binding<String> {
        Binding<String>(
            get: { self.contact.emergencyContact?[keyPath: keyPath] ?? "" },
            set: { newValue in
                if self.contact.emergencyContact == nil {
                    self.contact.emergencyContact = EmergencyContact(name: "", phone: "")
                }
                self.contact.emergencyContact?[keyPath: keyPath] = newValue
            }
        )
    }
}

private struct CollapsibleSection<Content: View>: View {
    @Binding var isExpanded: Bool
    let title: String
    let content: () -> Content
    var body: some View {
        VStack(alignment: .leading) {
            Button(action: { withAnimation(.easeInOut(duration: 0.2)) { isExpanded.toggle() } }) {
                HStack {
                    Text(title).font(.headline)
                    Spacer()
                    Image(systemName: "chevron.right").rotationEffect(.degrees(isExpanded ? 90 : 0))
                }.foregroundColor(.primary)
            }.buttonStyle(.plain)
            if isExpanded { content().padding(.top, 8) }
        }
    }
}
import SwiftUI

// This is a reusable UI component.
struct ExportShowTimingButton: View {
    // FIX: Updated to use the new 'Show' and 'Tour' models.
    let show: Show
    let tour: Tour

    @State private var pdfURL: URL?
    @State private var isSharing = false
    @State private var isProcessing = false

    var body: some View {
        Button(action: generateAndSharePDF) {
            if isProcessing {
                ProgressView()
            } else {
                HStack {
                    Image(systemName: "doc.text")
                    Text("Export Show Times")
                }
            }
        }
        .disabled(isProcessing)
        .sharingSheet(isPresented: $isSharing, items: [pdfURL].compactMap { $0 })
    }

    private func generateAndSharePDF() {
        isProcessing = true
        
        Task {
            // This now passes the new model types to the PDF renderer.
            // This will cause a new error in 'ShowTimingPDFView' which we will fix later.
            let viewToRender = ShowTimingPDFView(show: show, tour: tour)
            let url = await PDFGenerator.generate(view: viewToRender)
            
            await MainActor.run {
                self.pdfURL = url
                self.isSharing = url != nil
                self.isProcessing = false
            }
        }
    }
}

// NOTE: The sharingSheet extension and its related components remain unchanged.
// They are correct as they are.
extension View {
    func sharingSheet(isPresented: Binding<Bool>, items: [Any]) -> some View {
        self.modifier(SharingSheet(isPresented: isPresented, items: items))
    }
}

private struct SharingSheet: ViewModifier {
    @Binding var isPresented: Bool
    let items: [Any]

    func body(content: Content) -> some View {
        content
            .background(SharingSheetPresenter(isPresented: $isPresented, items: items))
    }
}

private struct SharingSheetPresenter: NSViewRepresentable {
    @Binding var isPresented: Bool
    let items: [Any]

    func makeNSView(context: Context) -> NSView {
        return NSView()
    }

    func updateNSView(_ nsView: NSView, context: Context) {
        if isPresented {
            let picker = NSSharingServicePicker(items: items)
            picker.delegate = context.coordinator
            
            DispatchQueue.main.async {
                picker.show(relativeTo: .zero, of: nsView, preferredEdge: .minY)
            }
        }
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, NSSharingServicePickerDelegate {
        var parent: SharingSheetPresenter
        
        init(_ parent: SharingSheetPresenter) {
            self.parent = parent
        }
        
        func sharingServicePicker(_ sharingServicePicker: NSSharingServicePicker, didChoose service: NSSharingService?, error: Error?) {
            parent.isPresented = false
        }
    }
}
import SwiftUI

struct EditableSwipeCard<Content: View>: View {
    let content: () -> Content
    let onDelete: () -> Void
    let onEdit: () -> Void

    init(onDelete: @escaping () -> Void, onEdit: @escaping () -> Void, @ViewBuilder content: @escaping () -> Content) {
        self.onDelete = onDelete
        self.onEdit = onEdit
        self.content = content
    }

    var body: some View {
        content()
            .swipeActions(edge: .trailing) {
                Button(role: .destructive, action: onDelete) {
                    Label("Delete", systemImage: "trash")
                }
            }
            .swipeActions(edge: .leading) {
                Button(action: onEdit) {
                    Label("Edit", systemImage: "pencil")
                }
                .tint(.blue)
            }
    }
}
import Foundation

enum ContactFilter: String, CaseIterable {
    case all = "All"
    case artist = "Artist"
    case supportAct = "Support Act"
    case crew = "Crew"
    case guest = "Guest"

    var displayName: String {
        switch self {
        case .all: return "All"
        case .artist: return "Artists"
        case .supportAct: return "Support Acts"
        case .crew: return "Crew"
        case .guest: return "Guests"
        }
    }
}
import SwiftUI
import FirebaseCore

@main
struct EncoreApp: App {
    @StateObject private var appState = AppState()
    @StateObject private var airportDataManager = AirportDataManager()

    init() {
        FirebaseApp.configure()
    }

    var body: some Scene {
        WindowGroup {
            if appState.userID == nil {
                SignInView()
                    .environmentObject(appState)
                    .environmentObject(airportDataManager)
            } else {
                SidebarContainerView()
                    .environmentObject(appState)
                    .environmentObject(airportDataManager)
            }
        }
    }
}
import SwiftUI

struct StyledButton: View {
    var title: String
    var action: () -> Void
    var fullWidth: Bool = false
    var showArrow: Bool = true

    var body: some View {
        Button(action: action) {
            HStack {
                Text(title)
                if showArrow {
                    Image(systemName: "arrow.right.circle.fill")
                }
                Spacer()
            }
            .padding()
            .frame(maxWidth: fullWidth ? .infinity : nil)
            .background(Color("#EEEEEE"))
            .foregroundColor(.black)
            .cornerRadius(12)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
import SwiftUI

struct GuestListCard: View {
    var guest: GuestListItemModel

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(guest.name).font(.headline)
                if let additional = guest.additionalGuests, !additional.isEmpty, additional != "0" {
                    Text("+\(additional)").font(.subheadline).foregroundColor(.gray)
                }
            }

            if let note = guest.note, !note.isEmpty {
                Text(note).font(.subheadline).foregroundColor(.gray)
            }
        }
        .padding(8)
        .background(Color.white.opacity(0.8))
        .cornerRadius(8)
    }
}
import SwiftUI

struct StyledInputField: View {
    var placeholder: String
    @Binding var text: String

    var body: some View {
        TextField(placeholder, text: $text)
            .padding(12)
            .background(Color.gray.opacity(0.06))
            .cornerRadius(10)
            .font(.body)
            .textFieldStyle(PlainTextFieldStyle())
    }
}
import Foundation

enum DatabaseSection: String, CaseIterable {
    case contacts = "Contacts"
    case venues = "Venues"
    case hotels = "Hotels"
}
import SwiftUI

// This creates a reusable secure field that matches your CustomTextField style.
struct CustomSecureField: View {
    let placeholder: String
    @Binding var text: String

    var body: some View {
        SecureField(placeholder, text: $text)
            .padding(12)
            .background(Color(.unemphasizedSelectedContentBackgroundColor))
            .cornerRadius(8)
            .textFieldStyle(.plain)
    }
}
import SwiftUI

struct ContentRouter: View {
    @EnvironmentObject var appState: AppState

    var body: some View {
        if appState.userID == nil {
            SignInView(appState: _appState)
        } else {
            TourListView()
                .environmentObject(appState)
        }
    }
}
import SwiftUI

struct StyledDropdown: View {
    let label: String
    @Binding var selection: String
    let options: [String]

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(label)
                .font(.subheadline.bold())
                .foregroundColor(.gray)

            Menu {
                ForEach(options, id: \.self) { option in
                    Button(action: { selection = option }) {
                        Text(option)
                    }
                }
            } label: {
                HStack {
                    Text(selection.isEmpty ? "Select" : selection)
                        .foregroundColor(selection.isEmpty ? .gray : .primary)
                    Spacer()
                    Image(systemName: "chevron.down")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.gray)
                }
                .padding(12)
                .background(Color.gray.opacity(0.06))
                .cornerRadius(10)
            }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct VenuesSection: View {
    let userID: String
    let searchText: String
    let selectedFilter: String
    @Binding var sortField: String
    @Binding var sortAscending: Bool

    // FIX: The state now uses our new, top-level 'Venue' model.
    @State private var venues: [Venue] = []
    @State private var isLoading: Bool = true
    @State private var listener: ListenerRegistration?

    var body: some View {
        VStack {
            if isLoading {
                Spacer()
                ProgressView().progressViewStyle(.circular)
                Spacer()
            } else {
                ScrollView {
                    // This will cause an error in VenueTableView next, which is expected.
                    VenueTableView(venues: filteredAndSorted(), sortField: $sortField, sortAscending: $sortAscending)
                }
            }
        }
        .onAppear(perform: setupListener)
        .onDisappear { listener?.remove() }
    }

    // --- FIX IS HERE ---
    private func setupListener() {
        self.isLoading = true
        listener?.remove()
        
        let db = Firestore.firestore()
        
        // This is now ONE simple, real-time listener on the top-level /venues collection.
        // It only fetches venues created by the current user.
        listener = db.collection("venues")
            .whereField("ownerId", isEqualTo: userID)
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error loading venues: \(error?.localizedDescription ?? "Unknown")")
                    self.isLoading = false
                    return
                }
                
                // We use Codable to automatically decode into our new [Venue] model.
                self.venues = documents.compactMap { try? $0.data(as: Venue.self) }
                self.isLoading = false
            }
    }

    private func filteredAndSorted() -> [Venue] {
        let filtered = venues.filter { venue in
            let matchesFilter = selectedFilter == "All" || venue.city == selectedFilter
            let matchesSearch = searchText.isEmpty || venue.name.lowercased().contains(searchText.lowercased())
            return matchesFilter && matchesSearch
        }

        return filtered.sorted { lhs, rhs in
            let lhsValue = sortFieldValue(lhs)
            let rhsValue = sortFieldValue(rhs)
            return sortAscending ? lhsValue < rhsValue : lhsValue > rhsValue
        }
    }

    private func sortFieldValue(_ venue: Venue) -> String {
        switch sortField {
        case "City": return venue.city
        default: return venue.name
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct ContactsSection: View {
    let userID: String
    let searchText: String
    let selectedFilter: String
    @Binding var sortField: String
    @Binding var sortAscending: Bool

    // FIX: The state now uses our new, top-level 'Contact' model.
    @State private var contacts: [Contact] = []
    @State private var isLoading: Bool = true
    @State private var contactToEdit: Contact?
    
    // FIX: Add a listener registration state variable to manage its lifecycle.
    @State private var listener: ListenerRegistration?

    var body: some View {
        Group {
            if isLoading {
                VStack { Spacer(); ProgressView().progressViewStyle(.circular); Spacer() }
            } else {
                // This will cause a build error next, which is expected.
                // We will fix ContactsTableView in the next step.
                ContactsTableView(
                    contacts: filteredAndSorted,
                    sortField: $sortField,
                    sortAscending: $sortAscending,
                    onContactSelected: { contact in
                        self.contactToEdit = contact
                    }
                )
            }
        }
        .onAppear(perform: setupListener)
        .onDisappear { listener?.remove() } // Clean up the listener
        .sheet(item: $contactToEdit) { contact in
            // This will cause a build error next, which is expected.
            // We will fix ContactEditView after we fix the table view.
            ContactEditView(contact: contact)
        }
    }

    private var filteredAndSorted: [Contact] {
        // This filtering logic is now much simpler.
        let filteredByRole = contacts.filter { contact in
            selectedFilter == "All" || contact.roles.contains(selectedFilter)
        }
        
        let filteredBySearch = filteredByRole.filter { contact in
            searchText.isEmpty ||
            contact.name.lowercased().contains(searchText.lowercased()) ||
            (contact.email ?? "").lowercased().contains(searchText.lowercased()) ||
            contact.roles.joined(separator: " ").lowercased().contains(searchText.lowercased())
        }
        
        // Sorting logic can be simplified if needed, but this works.
        return filteredBySearch.sorted { lhs, rhs in
            let lhsValue = sortFieldValue(lhs)
            let rhsValue = sortFieldValue(rhs)
            return sortAscending ? lhsValue < rhsValue : lhsValue > rhsValue
        }
    }
    
    private func sortFieldValue(_ contact: Contact) -> String {
        switch sortField {
        case "Name": return contact.name
        case "Role": return contact.roles.joined()
        case "Email": return contact.email ?? ""
        case "Phone": return contact.phone ?? ""
        default: return contact.name
        }
    }

    // --- FIX IS HERE ---
    private func setupListener() {
        self.isLoading = true
        listener?.remove() // Prevent duplicate listeners
        
        let db = Firestore.firestore()
        
        // This is now ONE simple, efficient query to the top-level /contacts collection.
        // It only fetches contacts created by the current user.
        listener = db.collection("contacts")
            .whereField("ownerId", isEqualTo: userID)
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error loading contacts: \(error?.localizedDescription ?? "Unknown")")
                    self.isLoading = false
                    return
                }
                
                // We use Codable to automatically decode into our new [Contact] model.
                self.contacts = documents.compactMap { try? $0.data(as: Contact.self) }
                self.isLoading = false
            }
    }
}
import SwiftUI
import CoreGraphics

// This service class handles the conversion of a SwiftUI View to a PDF file.

class PDFGenerator {
    
    @MainActor
    static func generate(view: some View) -> URL? {
        let renderer = ImageRenderer(content: view)
        
        // Create a temporary file URL
        let temporaryDirectory = FileManager.default.temporaryDirectory
        let fileName = "EncoreExport-\(UUID().uuidString).pdf"
        let url = temporaryDirectory.appendingPathComponent(fileName)
        
        renderer.render { size, context in
            var box = CGRect(x: 0, y: 0, width: size.width, height: size.height)
            
            guard var pdf = CGContext(url as CFURL, mediaBox: &box, nil) else {
                return
            }
            
            pdf.beginPDFPage(nil)
            context(pdf)
            pdf.endPDFPage()
            pdf.closePDF()
        }
        
        return url
    }
}
import Foundation
import FirebaseFirestore

struct GuestListItemModel: Identifiable {
    var id: String
    var name: String
    var note: String?
    var additionalGuests: String?

    init(from document: DocumentSnapshot) {
        let data = document.data() ?? [:]
        self.id = document.documentID
        self.name = data["name"] as? String ?? ""
        self.note = data["note"] as? String
        self.additionalGuests = data["additionalGuests"] as? String
    }

    func toFirestore() -> [String: Any] {
        return [
            "name": name,
            "note": note ?? "",
            "additionalGuests": additionalGuests ?? ""
        ]
    }
}
import Foundation
import FirebaseFirestore

// FIX: Added Equatable conformance
struct Tour: Codable, Identifiable, Equatable {
    @DocumentID var id: String?
    let ownerId: String
    var tourName: String
    var artist: String
    var startDate: Timestamp
    var endDate: Timestamp
    var posterURL: String?
    @ServerTimestamp var createdAt: Timestamp?
}
import Foundation
import FirebaseFirestore

struct SupportAct: Codable, Identifiable {
    @DocumentID var id: String?
    let tourId: String
    var name: String
    var type: ActType
    var contactEmail: String?

    enum ActType: String, Codable {
        case Touring, Local
    }
}
import Foundation
import FirebaseFirestore

struct Hotel: Codable, Identifiable {
    @DocumentID var id: String?
    let ownerId: String // The user who created this hotel entry
    var name: String
    var address: String?
    var city: String?
    var country: String?
    var contactInfo: String?
    @ServerTimestamp var createdAt: Timestamp?
}
import Foundation
import FirebaseFirestore

struct TourCrew: Codable, Identifiable {
    @DocumentID var id: String?
    let tourId: String
    let userId: String? // The User ID if they exist in the app
    let contactId: String? // The Contact ID for non-users
    var name: String
    var email: String?
    var roles: [String]
    var visibility: CrewVisibility
    let invitedBy: String // The User ID of the person who added them
    @ServerTimestamp var createdAt: Timestamp?

    enum CrewVisibility: String, Codable {
        case full, limited, temporary
    }
}
import Foundation
import FirebaseFirestore

struct Venue: Codable, Identifiable {
    @DocumentID var id: String?
    let ownerId: String // The user who created this venue entry
    var name: String
    var address: String?
    var city: String
    var country: String?
    var capacity: Int?
    var contactName: String?
    var contactEmail: String?
    var contactPhone: String?
    @ServerTimestamp var createdAt: Timestamp?
}
import Foundation
import FirebaseFirestore

struct ItineraryDay: Identifiable, Codable, Hashable {
    var id: String
    var date: Date
    var notes: String?

    init(from document: DocumentSnapshot) {
        let data = document.data() ?? [:]
        self.id = document.documentID
        self.date = (data["date"] as? Timestamp)?.dateValue() ?? Date()
        self.notes = data["notes"] as? String
    }

    func toFirestore() -> [String: Any] {
        return [
            "date": Timestamp(date: date),
            "notes": notes ?? ""
        ]
    }
}
import Foundation
import FirebaseFirestore

struct SupportActModel: Identifiable, Codable, Hashable {
    var id: String
    var name: String
    var type: String
    var createdAt: Date

    init(id: String, name: String, type: String, createdAt: Date = Date()) {
        self.id = id
        self.name = name
        self.type = type
        self.createdAt = createdAt
    }

    init?(from document: DocumentSnapshot) {
        let data = document.data()
        guard let name = data?["name"] as? String,
              let type = data?["type"] as? String,
              let createdAt = (data?["createdAt"] as? Timestamp)?.dateValue()
        else { return nil }

        self.id = document.documentID
        self.name = name
        self.type = type
        self.createdAt = createdAt
    }

    func toFirestore() -> [String: Any] {
        return [
            "name": name,
            "type": type,
            "createdAt": createdAt
        ]
    }
}
import Foundation
import FirebaseFirestore

// FIX: Added Equatable conformance for SwiftUI animations.
struct SetlistItem: Codable, Identifiable, Equatable {
    @DocumentID var id: String?
    let showId: String
    let tourId: String
    var order: Int
    var type: ItemType

    // Song-specific details
    var songTitle: String?
    var bpm: Int?
    var key: String?
    var tonality: String?
    var performanceNotes: String?
    var lightingNotes: String?
    var audioNotes: String?
    var videoNotes: String?
    
    // Marker-specific details
    var markerDescription: String?
    var markerDuration: TimeInterval?

    enum ItemType: String, Codable {
        case song, marker
    }
}
import Foundation
import FirebaseFirestore

struct Flight: Codable, Identifiable {
    @DocumentID var id: String?
    let tourId: String
    var airline: String?
    var flightNumber: String?
    var departureTimeUTC: Timestamp
    var arrivalTimeUTC: Timestamp
    var origin: String // Airport code, e.g., "JFK"
    var destination: String // Airport code, e.g., "LHR"
    var notes: String?
    var passengers: [String] // Array of TourCrew IDs
}
import Foundation
import FirebaseFirestore

struct Show: Codable, Identifiable {
    @DocumentID var id: String?
    let tourId: String
    var date: Timestamp
    var city: String
    var country: String?
    var venueName: String
    var venueAddress: String
    
    var contactName: String?
    var contactEmail: String?
    var contactPhone: String?
    
    // All nullable timestamps for flexibility
    var venueAccess: Timestamp?
    var loadIn: Timestamp?
    var soundCheck: Timestamp?
    var doorsOpen: Timestamp?
    var headlinerSetTime: Timestamp?
    var headlinerSetDurationMinutes: Int?
    var packOut: Timestamp?
    var packOutNextDay: Bool?
    
    // FIX: Added a property to store the IDs of linked support acts.
    var supportActIds: [String]?
    
    @ServerTimestamp var createdAt: Timestamp?
}
import Foundation
import FirebaseFirestore

struct PersonalNote: Codable, Identifiable {
    @DocumentID var id: String?
    let setlistItemId: String // Crucial link to the SetlistItem
    let showId: String
    let tourId: String

    var content: String
    let authorCrewMemberId: String
    var forCrewMemberId: String?
    @ServerTimestamp var createdAt: Timestamp?
}
import Foundation
import FirebaseFirestore

struct ItineraryItem: Codable, Identifiable, Equatable {
    @DocumentID var id: String?
    let tourId: String
    let showId: String?
    var title: String
    var type: String
    var timeUTC: Timestamp
    
    // FIX: Added the missing 'subtitle' property.
    var subtitle: String?
    
    var notes: String?
    var timezone: String?
}
import Foundation
import FirebaseFirestore

struct ShowModel: Identifiable, Codable, Hashable {
    var id: String
    var city: String
    var country: String?
    var venue: String
    var address: String

    var contactName: String?
    var contactEmail: String?
    var contactPhone: String?

    var date: Date
    var venueAccess: Date?

    var loadIn: Date?
    var soundCheck: Date?
    var doorsOpen: Date?

    struct SupportAct: Codable, Hashable, Identifiable {
        var id = UUID()
        var name: String
        var type: String
        var soundCheck: Date
        var setTime: Date
        var changeoverMinutes: Int
        
        // CodingKeys to exclude `id` from Firestore operations.
        enum CodingKeys: String, CodingKey {
            case name, type, soundCheck, setTime, changeoverMinutes
        }
    }
    var supportActs: [SupportAct] = []

    struct Headliner: Codable, Hashable {
        var soundCheck: Date
        var setTime: Date
        var setDurationMinutes: Int
    }
    var headliner: Headliner?

    var packOut: Date?
    var packOutNextDay: Bool
    var createdAt: Date

    init?(from document: DocumentSnapshot) {
        let data = document.data()
        guard
            let city = data?["city"] as? String,
            let venue = data?["venue"] as? String,
            let address = data?["address"] as? String,
            let dateTS = data?["date"] as? Timestamp,
            let createdAtTS = data?["createdAt"] as? Timestamp
        else { return nil }

        self.id = document.documentID
        self.city = city
        self.country = data?["country"] as? String
        self.venue = venue
        self.address = address

        self.contactName = data?["contactName"] as? String
        self.contactEmail = data?["contactEmail"] as? String
        self.contactPhone = data?["contactPhone"] as? String

        self.date = dateTS.dateValue()
        self.venueAccess = (data?["venueAccess"] as? Timestamp)?.dateValue()

        self.loadIn = (data?["loadIn"] as? Timestamp)?.dateValue()
        self.soundCheck = (data?["soundCheck"] as? Timestamp)?.dateValue()
        self.doorsOpen = (data?["doorsOpen"] as? Timestamp)?.dateValue()

        // Headliner: Allow partial creation
        let headlinerSetTime = (data?["headlinerSetTime"] as? Timestamp)?.dateValue()
        let headlinerSoundCheck = (data?["headlinerSoundCheck"] as? Timestamp)?.dateValue()
        let headlinerSetDurationMinutes = data?["headlinerSetDurationMinutes"] as? Int

        if headlinerSetTime != nil {
            self.headliner = Headliner(
                soundCheck: headlinerSoundCheck ?? headlinerSetTime!,
                setTime: headlinerSetTime!,
                setDurationMinutes: headlinerSetDurationMinutes ?? 0
            )
        }

        self.packOut = (data?["packOut"] as? Timestamp)?.dateValue()
        self.packOutNextDay = data?["packOutNextDay"] as? Bool ?? false
        self.createdAt = createdAtTS.dateValue()
    }
}
import Foundation

struct Airport: Codable {
    let icao: String
    let iata: String
    let name: String
    let city: String
    let state: String
    let country: String
    let elevation: Int
    let lat: Double
    let lon: Double
    let tz: String
}

typealias AirportDictionary = [String: Airport]

struct AirportEntry: Identifiable {
    let id = UUID()
    let name: String  // e.g. "Auckland International Airport (AKL)"
    let iata: String
    let city: String
    let country: String
}
import Foundation
import FirebaseFirestore

struct Contact: Codable, Identifiable {
    @DocumentID var id: String?
    let ownerId: String
    var name: String
    var roles: [String]
    var email: String?
    var phone: String?
    var notes: String?
    var location: String?
    var profileImageURL: String?
    var dateOfBirth: Timestamp?
    var countryOfBirth: String?
    var passport: PassportInfo?
    var documents: [DocumentInfo]?
    var emergencyContact: EmergencyContact?
    var allergies: String?
    var medications: String?
    var linkedUserId: String?
    @ServerTimestamp var createdAt: Timestamp?
}

struct PassportInfo: Codable, Hashable {
    var passportNumber: String
    var issuedDate: Timestamp
    var expiryDate: Timestamp
    var issuingCountry: String
}

struct DocumentInfo: Identifiable, Codable, Hashable {
    @DocumentID var id: String?
    var name: String
    var url: String
}

struct EmergencyContact: Codable, Hashable {
    var name: String
    var phone: String
}
import SwiftUI

struct SwipeableCardContainer<Content: View>: View {
    let content: () -> Content
    let onDelete: () -> Void
    let onEdit: () -> Void

    @State private var offsetX: CGFloat = 0
    @GestureState private var dragOffset: CGFloat = 0

    private let swipeThreshold: CGFloat = 80

    var body: some View {
        ZStack(alignment: .leading) {
            // FULL BACKGROUND ACTIONS (no corner radius)
            fullSwipeBackground

            // CARD FLOATS ON TOP
            content()
                .offset(x: offsetX + dragOffset)
                .gesture(
                    DragGesture()
                        .updating($dragOffset) { value, state, _ in
                            state = value.translation.width
                        }
                        .onEnded(onDragEnded)
                )
                .animation(.spring(), value: offsetX)
        }
        .padding(.horizontal)
    }

    private var fullSwipeBackground: some View {
        HStack(spacing: 0) {
            // Edit zone on left
            Rectangle()
                .fill(Color.blue)
                .frame(width: 80)
                .overlay(
                    Image(systemName: "pencil")
                        .foregroundColor(.white)
                        .font(.title)
                )

            Spacer()

            // Delete zone on right
            Rectangle()
                .fill(Color.red)
                .frame(width: 80)
                .overlay(
                    Image(systemName: "trash")
                        .foregroundColor(.white)
                        .font(.title)
                )
        }
    }

    private func onDragEnded(_ value: DragGesture.Value) {
        let totalOffset = offsetX + value.translation.width

        if totalOffset > swipeThreshold {
            onEdit()
            offsetX = 0
        } else if totalOffset < -swipeThreshold {
            onDelete()
            offsetX = 0
        } else {
            offsetX = 0
        }
    }
}
import SwiftUI

struct CustomSearchField<ResultType: Identifiable & CustomStringConvertible>: View {
    let placeholder: String
    @Binding var text: String
    var results: [ResultType]
    var onSelect: (ResultType) -> Void

    @State private var showDropdown = false

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            TextField(placeholder, text: $text, onEditingChanged: { editing in
                showDropdown = editing
            })
            .textFieldStyle(RoundedBorderTextFieldStyle())
            .onChange(of: text) { _ in
                showDropdown = true
            }

            if showDropdown && !results.isEmpty {
                ScrollView {
                    VStack(alignment: .leading, spacing: 0) {
                        ForEach(results) { result in
                            Button(action: {
                                onSelect(result)
                                showDropdown = false
                            }) {
                                Text(result.description)
                                    .foregroundColor(.primary)
                                    .padding(8)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(Color(nsColor: .controlBackgroundColor))
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                    }
                }
                .frame(maxHeight: 150)
                .background(Color(nsColor: .controlBackgroundColor))
                .cornerRadius(8)
                .shadow(radius: 2)
            }
        }
    }
}
import Foundation
import FirebaseFirestore

// This extension teaches Swift how to compare two Timestamps.
extension Timestamp: Comparable {
    public static func < (lhs: Timestamp, rhs: Timestamp) -> Bool {
        return lhs.dateValue() < rhs.dateValue()
    }
}
import SwiftUI

struct ToggleSelector: View {
    @Binding var selected: String
    var options: [String]
    var onChange: ((String) -> Void)? = nil

    var body: some View {
        HStack {
            ForEach(options, id: \.self) { option in
                Button(option) {
                    selected = option
                    onChange?(option)
                }
                .padding(.vertical, 10)
                .padding(.horizontal, 18)
                .background(selected == option ? Color.gray.opacity(0.3) : Color.clear)
                .cornerRadius(10)
            }
        }
    }
}
import SwiftUI
import Kingfisher // Or SDWebImageSwiftUI, depending on your library

struct TourCard: View {
    // This now accepts our new Tour struct
    let tour: Tour

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            GeometryReader { geo in
                // Using Kingfisher, but you can use your preferred image loading library
                KFImage(URL(string: tour.posterURL ?? ""))
                    .placeholder {
                        ZStack {
                            Color.gray.opacity(0.1)
                            Image(systemName: "photo")
                                .foregroundColor(.gray)
                                .font(.system(size: 24))
                        }
                    }
                    .resizable()
                    .scaledToFill()
                    .frame(width: geo.size.width, height: geo.size.height)
                    .clipped()
            }
            .aspectRatio(2/3, contentMode: .fit)
            .cornerRadius(8)

            Text(tour.artist)
                .font(.system(size: 14, weight: .semibold))
                .foregroundColor(.primary)

            // Using the new 'tourName' property
            Text(tour.tourName)
                .font(.system(size: 12))
                .foregroundColor(.secondary)
        }
        .frame(width: 160)
    }
}
import SwiftUI

struct StyledStepper: View {
    var label: String
    @Binding var value: Int
    var step: Int

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text(label).font(.caption)
            Stepper("\(value) min", value: $value, in: 0...300, step: step)
                .labelsHidden()
        }
    }
}
import SwiftUI

struct CustomTextField: View {
    var placeholder: String
    @Binding var text: String

    var body: some View {
        ZStack(alignment: .leading) {
            if text.isEmpty {
                Text(placeholder)
                    .foregroundColor(.gray)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 12)
            }

            TextField("", text: $text)
                .padding(.horizontal, 12)
                .padding(.vertical, 12)
                .background(Color.clear)
                .textFieldStyle(PlainTextFieldStyle())
        }
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
    }
}
import SwiftUI

struct StyledDateField: View {
    @Binding var date: Date

    var body: some View {
        DatePicker("", selection: $date, displayedComponents: [.date])
            .labelsHidden()
            .padding(12)
            .background(Color.gray.opacity(0.06))
            .cornerRadius(10)
            .datePickerStyle(.compact)
            .frame(maxWidth: 200)
    }
}
import SwiftUI

// A reusable styled TextEditor that includes a placeholder.
struct CustomTextEditor: View {
    let placeholder: String
    @Binding var text: String

    var body: some View {
        ZStack(alignment: .topLeading) {
            if text.isEmpty {
                Text(placeholder)
                    .foregroundColor(.gray.opacity(0.75))
                    .padding(.horizontal, 8)
                    .padding(.vertical, 8)
                    .allowsHitTesting(false)
            }
            
            TextEditor(text: $text)
                .scrollContentBackground(.hidden) // Make background transparent
                .padding(4)
                .frame(minHeight: 80, alignment: .top)
        }
        .background(Color.gray.opacity(0.06))
        .cornerRadius(10)
    }
}
import SwiftUI

struct CustomSegmentedPicker<T: Hashable & CustomStringConvertible>: View {
    @Binding var selected: T
    var options: [T]
    var labels: [String]? = nil

    var body: some View {
        HStack(spacing: 8) {
            ForEach(options, id: \.self) { option in
                Button(action: {
                    selected = option
                }) {
                    Text(labels?[options.firstIndex(of: option) ?? 0] ?? option.description)
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(selected == option ? .white : .black)
                        .padding(.vertical, 10)
                        .padding(.horizontal, 16)
                        .background(selected == option ? Color.black : Color.gray.opacity(0.2))
                        .cornerRadius(8)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
    }
}

extension Bool: CustomStringConvertible {
    public var description: String {
        self ? "Yes" : "No"
    }
}
import Foundation
import FirebaseFirestore

class TourDataManager {
    static let shared = TourDataManager()
    private let db = Firestore.firestore()

    private init() {}

    func deleteFlight(ownerUserID: String, tourID: String, flightID: String, completion: @escaping (Error?) -> Void) {
        let batch = db.batch()

        // 1. Reference to the master flight document in /flights
        let flightRef = db.collection("users").document(ownerUserID).collection("tours").document(tourID).collection("flights").document(flightID)
        batch.deleteDocument(flightRef)

        // 2. Query to find the corresponding itinerary item(s) to delete
        let itineraryItemsQuery = db.collectionGroup("items")
            .whereField("flightId", isEqualTo: flightID)
            // This where clause assumes you are running this against a specific tour's context,
            // which requires a composite index in Firestore.
            // A simpler query if flightIds are globally unique is to just query on flightId.

        itineraryItemsQuery.getDocuments { (snapshot, error) in
            if let error = error {
                // If query fails, do not proceed with deletion
                completion(error)
                return
            }
            
            // Add all found itinerary items to the batch for deletion
            snapshot?.documents.forEach { doc in
                batch.deleteDocument(doc.reference)
            }
            
            // 3. Commit the batch delete for both collections
            batch.commit { err in
                completion(err)
            }
        }
    }

    func updateFlightNote(ownerUserID: String, tourID: String, flightID: String, newNote: String, completion: @escaping (Error?) -> Void) {
        let batch = db.batch()

        // 1. Update the note on the master flight record.
        let flightRef = db.collection("users").document(ownerUserID).collection("tours").document(tourID).collection("flights").document(flightID)
        batch.updateData(["note": newNote], forDocument: flightRef)
        
        // 2. Query to find and update the note on the corresponding itinerary item(s).
        let itineraryItemsQuery = db.collectionGroup("items")
            .whereField("flightId", isEqualTo: flightID)

        itineraryItemsQuery.getDocuments { snapshot, error in
            if let error = error {
                completion(error)
                return
            }
            
            snapshot?.documents.forEach { doc in
                batch.updateData(["note": newNote], forDocument: doc.reference)
            }
            
            // 3. Commit the batch update for both collections
            batch.commit { err in
                completion(err)
            }
        }
    }
}
import Foundation
@preconcurrency import FirebaseCore
@preconcurrency import FirebaseAuth
import FirebaseFirestore
import GoogleSignIn
import AppKit

class AuthManager: ObservableObject {

    static let shared = AuthManager()
    private init() {
        if FirebaseApp.app() == nil {
            FirebaseApp.configure()
        }
        self.user = Auth.auth().currentUser
    }

    @Published var user: User?

    func handleGoogleSignIn(presentingWindow: NSWindow) async -> User? {
        // ADDED: Log the start of the process.
        print("LOG: 1. AuthManager.handleGoogleSignIn called.")
        
        let config = GIDConfiguration(clientID: FirebaseApp.app()?.options.clientID ?? "")
        GIDSignIn.sharedInstance.configuration = config

        do {
            guard let result = try? await GIDSignIn.sharedInstance.signIn(withPresenting: presentingWindow) else {
                print("LOG: ❌ GIDSignIn returned nil. User may have cancelled.")
                return nil
            }
            
            // ADDED: Log success from Google Sign-In SDK.
            print("LOG: 2. GIDSignIn successful. User: \(result.user.profile?.name ?? "N/A")")
            
            guard let idToken = result.user.idToken?.tokenString else {
                print("LOG: ❌ Could not get idToken from Google result.")
                return nil
            }
            
            let credential = GoogleAuthProvider.credential(withIDToken: idToken, accessToken: result.user.accessToken.tokenString)
            
            let authResult = try await Auth.auth().signIn(with: credential)
            self.user = authResult.user
            
            // ADDED: Log success from Firebase Auth.
            print("LOG: 3. Firebase signIn successful. UID: \(authResult.user.uid)")
            
            await self.createUserDocumentIfNeeded(userID: authResult.user.uid)
            
            return authResult.user
            
        } catch {
            // ADDED: Log any errors during the process.
            print("LOG: ❌ ERROR in AuthManager.handleGoogleSignIn: \(error.localizedDescription)")
            return nil
        }
    }

    private func createUserDocumentIfNeeded(userID: String) async {
        let db = Firestore.firestore()
        let ref = db.collection("users").document(userID)

        do {
            let document = try await ref.getDocument()
            if document.exists {
                print("LOG: User document already exists for UID: \(userID)")
                return
            }
            
            let userData: [String: Any] = [ "uid": userID, "email": self.user?.email ?? "", "displayName": self.user?.displayName ?? "", "createdAt": Timestamp(date: Date()) ]
            try await ref.setData(userData)
            print("LOG: ✅ User document created for UID: \(userID)")

        } catch {
            print("LOG: ❌ Failed creating user document: \(error.localizedDescription)")
        }
    }
  
    func signOut() {
        do {
            try Auth.auth().signOut()
            self.user = nil
        } catch {
            print("❌ Firebase Sign Out Failed: \(error.localizedDescription)")
        }
    }
}
import Foundation

enum VenueFilter: String, CaseIterable {
    case all = "All"
    case Auckland
    case Wellington
    case Christchurch
    case Other

    var displayName: String {
        switch self {
        case .all: return "All"
        case .Auckland: return "Auckland"
        case .Wellington: return "Wellington"
        case .Christchurch: return "Christchurch"
        case .Other: return "Other"
        }
    }
}
import SwiftUI

struct SortableHeader: View {
    let title: String
    let field: String
    @Binding var sortField: String
    @Binding var sortAscending: Bool

    var body: some View {
        Button(action: {
            if sortField == field {
                sortAscending.toggle()
            } else {
                sortField = field
                sortAscending = true
            }
        }) {
            HStack(spacing: 4) {
                Text(title).bold()
                if sortField == field {
                    Image(systemName: sortAscending ? "arrow.up" : "arrow.down")
                        .font(.caption)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .buttonStyle(.plain)
    }
}
import SwiftUI

struct CustomDateField: View {
    @Binding var date: Date
    @State private var isShowingCalendar = false

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 8)
                .fill(Color.gray.opacity(0.05))

            Button(action: {
                isShowingCalendar.toggle()
            }) {
                HStack {
                    Text(date.formatted(date: .abbreviated, time: .omitted))
                        .foregroundColor(.primary)
                        .padding(.leading, 4)

                    Spacer()

                    Image(systemName: "calendar")
                        .foregroundColor(.gray)
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 10)
            }
            .buttonStyle(PlainButtonStyle())
            .popover(isPresented: $isShowingCalendar, arrowEdge: .bottom) {
                VStack {
                    DatePicker(
                        "",
                        selection: $date,
                        displayedComponents: .date
                    )
                    .datePickerStyle(GraphicalDatePickerStyle())
                    .labelsHidden()
                    .scaleEffect(1.2) // 👈 Only scales the calendar
                }
                .frame(width: 190, height: 200) // 👈 Adjusted to suit scaled calendar
            }
        }
        .frame(height: 36)
    }
}
import SwiftUI

struct StyledTimePicker: View {
    var label: String
    @Binding var time: Date

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            if !label.isEmpty {
                Text(label)
                    .font(.subheadline.bold())
                    .foregroundColor(.gray)
            }
            DatePicker("", selection: $time, displayedComponents: .hourAndMinute)
                .labelsHidden()
                .padding(12)
                .background(Color.gray.opacity(0.06))
                .cornerRadius(10)
                .datePickerStyle(.compact)
                .frame(height: 44)
        }
    }
}
import SwiftUI

struct ItineraryItemCard: View {
    // FIX: Updated to use the new 'ItineraryItem' model.
    let item: ItineraryItem
    
    // These properties are kept for API compatibility with the parent view.
    let isExpanded: Bool
    let onExpandToggle: () -> Void
    let onEdit: () -> Void
    let onDelete: () -> Void

    var body: some View {
        // The overall UI structure is preserved.
        Button(action: onExpandToggle) {
            VStack(spacing: 0) {
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        // FIX: Gets the icon by converting the 'type' string into our ItineraryItemType enum.
                        // This resolves the "no member 'iconName'" error.
                        Image(systemName: ItineraryItemType(rawValue: item.type)?.iconName ?? "questionmark.circle")
                            .font(.title2)
                        
                        Text(item.title).font(.headline)
                        Spacer()
                        
                        // FIX: Uses the new timeUTC property and gets its dateValue().
                        Text(item.timeUTC.dateValue().formatted(date: .omitted, time: .shortened))
                    }

                    if let subtitle = item.subtitle, !subtitle.isEmpty {
                        Text(subtitle).font(.subheadline).foregroundColor(.gray)
                    }
                    
                    // FIX: Uses the new 'notes' property (plural).
                    if let note = item.notes, !note.isEmpty {
                        Text(note).font(.subheadline).foregroundColor(.gray)
                    }
                }
                .padding()

                if isExpanded {
                    // The expanded view with Edit/Delete buttons remains unchanged.
                    expandedActionView
                }
            }
            .background(Color.gray.opacity(0.1))
            .cornerRadius(20)
        }
        .buttonStyle(.plain)
    }
    
    private var expandedActionView: some View {
        VStack(spacing: 16) {
            HStack(spacing: 24) {
                Button(action: onEdit) {
                    Text("Edit")
                        .fontWeight(.semibold)
                        .padding(.vertical, 10)
                        .frame(maxWidth: .infinity)
                        .foregroundColor(.white)
                        .background(Color(red: 116/255, green: 151/255, blue: 173/255))
                        .cornerRadius(12)
                }
                .buttonStyle(.plain)

                Button(action: onDelete) {
                    Text("Delete")
                        .fontWeight(.semibold)
                        .padding(.vertical, 10)
                        .frame(maxWidth: .infinity)
                        .foregroundColor(.white)
                        .background(Color(red: 193/255, green: 106/255, blue: 106/255))
                        .cornerRadius(12)
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal)
        }
        .padding(.top, 16)
        .padding(.bottom, 12)
        .transition(.opacity)
    }
}
import SwiftUI
import FirebaseFirestore

struct EditVenueNotesView: View {
    var userID: String
    var tourID: String
    var showID: String
    var notes: String
    var onSave: () -> Void

    @Environment(\.dismiss) var dismiss
    @State private var newNotes = ""

    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            Text("Edit Venue Notes").font(.largeTitle.bold())

            TextEditor(text: $newNotes)
                .frame(height: 200)
                .border(Color.gray.opacity(0.5))

            Button("Save") {
                saveNotes()
            }
            .buttonStyle(.borderedProminent)
            Spacer()
        }
        .padding()
        .frame(width: 400)
        .onAppear { newNotes = notes }
    }

    private func saveNotes() {
        let db = Firestore.firestore()
        db.collection("users").document(userID).collection("tours").document(tourID)
            .collection("shows").document(showID).updateData(["venueNotes": newNotes]) { _ in
                dismiss()
                onSave()
            }
    }
}
import SwiftUI

struct WrapView<Data: RandomAccessCollection, Content: View>: View where Data.Element: Hashable {
    var items: Data
    var content: (Data.Element) -> Content

    @State private var totalHeight = CGFloat.zero

    var body: some View {
        GeometryReader { geometry in
            self.generateContent(in: geometry)
        }
        .frame(height: totalHeight)
    }

    private func generateContent(in g: GeometryProxy) -> some View {
        var width = CGFloat.zero
        var height = CGFloat.zero

        return ZStack(alignment: .topLeading) {
            ForEach(items, id: \.self) { item in
                content(item)
                    .padding([.horizontal, .vertical], 4)
                    .alignmentGuide(.leading) { d in
                        if abs(width - d.width) > g.size.width {
                            width = 0
                            height -= d.height
                        }
                        let result = width
                        if item == items.last {
                            width = 0
                        } else {
                            width -= d.width
                        }
                        return result
                    }
                    .alignmentGuide(.top) { _ in
                        let result = height
                        if item == items.last {
                            height = 0
                        }
                        return result
                    }
            }
        }
    }
}
import SwiftUI
import FirebaseFirestore
import Kingfisher

struct DashboardView: View {
    @EnvironmentObject var appState: AppState

    // FIX: State variables now use the new, simple model types.
    @State private var todayItems: [ItineraryItem] = []
    @State private var currentTour: Tour?
    @State private var sharedTours: [Tour] = []
    
    @State private var isLoading = true

    private var compactDateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateFormat = "d MMM"
        return formatter
    }

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 24) {
                header
                
                if isLoading {
                    ProgressView("Loading Dashboard...")
                        .frame(maxWidth: .infinity, alignment: .center)
                        .padding(.top, 100)
                } else {
                    topPanels
                    sharedWithYouSection
                }
            }
            .padding(30)
        }
        .onAppear(perform: loadDashboardData)
    }

    // MARK: - Main UI Sections

    private var header: some View {
        HStack {
            Text("Dashboard").font(.largeTitle.bold())
            Spacer()
            Button(action: {}) {
                Image(systemName: "plus")
                    .fontWeight(.semibold).foregroundColor(.primary)
                    .frame(width: 36, height: 36)
                    .background(Color(nsColor: .controlBackgroundColor)).clipShape(Circle())
            }.buttonStyle(.plain)
        }
    }

    private var topPanels: some View {
        HStack(alignment: .top, spacing: 24) {
            todaySection.layoutPriority(1)
            if let tour = currentTour {
                currentTourSection(tour: tour).layoutPriority(1)
            } else {
                noCurrentTourPlaceholder
            }
        }
    }

    @ViewBuilder
    private var sharedWithYouSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Shared With Me").font(.title2.bold())
            if sharedTours.isEmpty {
                Text("No tours have been shared with you.").foregroundColor(.secondary).padding()
                    .frame(maxWidth: .infinity, alignment: .center).background(Color(nsColor: .controlBackgroundColor)).cornerRadius(12)
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 16) {
                        ForEach(sharedTours) { tour in
                            Button(action: {
                                // This will need to be updated once AppState uses the new Tour model
                                // appState.selectedTour = tour
                            }) {
                                // This will use a new TourCard view we'll create next
                                // For now, a placeholder
                                Text(tour.tourName).padding().background(Color.blue).foregroundColor(.white).cornerRadius(8)
                            }.buttonStyle(.plain)
                        }
                    }
                }
            }
        }.padding(.top)
    }

    // MARK: - Panel Subviews
    
    private var todaySection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Today").font(.title2.bold())
            if todayItems.isEmpty {
                Text("No events scheduled for today.").font(.subheadline).foregroundColor(.secondary).padding()
                    .frame(maxWidth: .infinity, minHeight: 150).background(Color(nsColor: .controlBackgroundColor)).cornerRadius(12)
            } else {
                ScrollView {
                    VStack(spacing: 10) {
                        ForEach(todayItems) { item in
                            // This will use a new ItineraryCard view we'll create next
                            // For now, a placeholder
                            Text(item.title).padding().frame(maxWidth: .infinity, alignment: .leading).background(Color.gray.opacity(0.1)).cornerRadius(8)
                        }
                    }
                }
                .frame(height: 300)
            }
        }
    }
    
    private func currentTourSection(tour: Tour) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Current Tour").font(.title2.bold())
            HStack(spacing: 16) {
                DashboardTourCard(posterURL: tour.posterURL)
                    .frame(width: 180)
                
                VStack(alignment: .leading, spacing: 8) {
                    // FIX: Using new property name `tourName`
                    Text(tour.tourName).font(.title3.bold())
                    Text(tour.artist).font(.subheadline).foregroundColor(.secondary)
                    // FIX: Using .dateValue() on the Timestamps
                    Text("\(compactDateFormatter.string(from: tour.startDate.dateValue())) - \(compactDateFormatter.string(from: tour.endDate.dateValue()))")
                        .font(.caption).foregroundColor(.secondary)
                    Spacer()
                    // This will need to be updated once AppState uses the new Tour model
                    // StyledButtonV2(title: "Go to tour", action: { appState.selectedTour = tour })
                    // StyledButtonV2(title: "Add Show", action: {})
                }
            }
            .padding().background(Color(nsColor: .controlBackgroundColor)).cornerRadius(12)
        }
    }
    
    private struct DashboardTourCard: View {
        let posterURL: String?
        var body: some View {
            KFImage(URL(string: posterURL ?? ""))
                .placeholder { ZStack { Color.gray.opacity(0.1); Image(systemName: "photo") } }
                .resizable().scaledToFill()
                .frame(width: 180).aspectRatio(2/3, contentMode: .fit).cornerRadius(8)
        }
    }
    
    private var noCurrentTourPlaceholder: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Current Tour").font(.title2.bold())
            Text("No tour is currently active.").foregroundColor(.secondary).padding()
                .frame(maxWidth: .infinity, minHeight: 150).background(Color(nsColor: .controlBackgroundColor)).cornerRadius(12)
        }
    }

    // MARK: - Data Loading (HEAVILY REFACTORED)

    private func loadDashboardData() {
        guard let userID = appState.userID else { return }
        self.isLoading = true
        
        let group = DispatchGroup()
        
        group.enter()
        loadCurrentTour(userID: userID) { tour in
            self.currentTour = tour
            if let activeTour = tour, let tourID = activeTour.id {
                self.loadTodayItems(tourID: tourID) { items in
                    self.todayItems = items.sorted(by: { $0.timeUTC.dateValue() < $1.timeUTC.dateValue() })
                    group.leave()
                }
            } else {
                self.todayItems = []
                group.leave()
            }
        }
        
        group.enter()
        loadSharedTours(userID: userID) { tours in
            self.sharedTours = tours
            group.leave()
        }
        
        group.notify(queue: .main) {
            self.isLoading = false
        }
    }
    
    private func loadCurrentTour(userID: String, completion: @escaping (Tour?) -> Void) {
        let db = Firestore.firestore()
        let now = Timestamp(date: Date())
        
        // Query the new top-level /tours collection
        db.collection("tours")
            .whereField("ownerId", isEqualTo: userID)
            .whereField("startDate", isLessThanOrEqualTo: now)
            .getDocuments { snapshot, _ in
                let activeTours = snapshot?.documents
                    .compactMap { try? $0.data(as: Tour.self) }
                    .filter { $0.endDate >= now }
                completion(activeTours?.first)
            }
    }
    
    // Massively simplified function
    private func loadTodayItems(tourID: String, completion: @escaping ([ItineraryItem]) -> Void) {
        let db = Firestore.firestore()
        
        // Define the time range for "Today"
        let calendar = Calendar.current
        let startOfToday = calendar.startOfDay(for: Date())
        let startOfTomorrow = calendar.date(byAdding: .day, value: 1, to: startOfToday)!
        
        // A single, simple query to the top-level /itineraryItems collection
        db.collection("itineraryItems")
            .whereField("tourId", isEqualTo: tourID)
            .whereField("timeUTC", isGreaterThanOrEqualTo: Timestamp(date: startOfToday))
            .whereField("timeUTC", isLessThan: Timestamp(date: startOfTomorrow))
            .getDocuments { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error fetching today's items: \(error?.localizedDescription ?? "Unknown")")
                    completion([])
                    return
                }
                let items = documents.compactMap { try? $0.data(as: ItineraryItem.self) }
                completion(items)
            }
    }
    
    private func loadSharedTours(userID: String, completion: @escaping ([Tour]) -> Void) {
        let db = Firestore.firestore()
        let sharedToursRef = db.collection("users").document(userID).collection("sharedTours")
        
        sharedToursRef.getDocuments { snapshot, error in
            guard let documents = snapshot?.documents, !documents.isEmpty else {
                completion([])
                return
            }
            
            // Get all the IDs of the tours shared with the user
            let tourIDs = documents.map { $0.documentID }
            
            // Fetch all those tours in a single, efficient query from the top-level /tours collection
            db.collection("tours").whereField(FieldPath.documentID(), in: tourIDs)
                .getDocuments { tourSnapshot, error in
                    guard let tourDocuments = tourSnapshot?.documents else {
                        completion([])
                        return
                    }
                    let tours = tourDocuments.compactMap { try? $0.data(as: Tour.self) }
                    completion(tours)
                }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct TourCrewView: View {
    var tourID: String
    var ownerUserID: String

    // FIX: The state now uses our new top-level TourCrew model.
    @State private var crewMembers: [TourCrew] = []
    @State private var showAddCrew = false
    @State private var listener: ListenerRegistration?

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            SectionHeader(title: "Crew", onAdd: {
                showAddCrew = true
            })
            .sheet(isPresented: $showAddCrew) {
                // This call is now correct, as AddCrewPopupView has been refactored.
                AddCrewPopupView(tourID: tourID)
            }

            VStack(spacing: 8) {
                // FIX: The ForEach now iterates correctly over the new [TourCrew] array.
                // The 'id' is implicitly handled by the Identifiable conformance.
                ForEach(crewMembers) { member in
                    HStack {
                        Text(member.roles.joined(separator: ", ")).font(.subheadline)
                        Spacer()
                        Text(member.name).font(.subheadline).bold()
                    }
                    .padding(.vertical, 4)
                }
            }
            .padding(16)
            .frame(maxWidth: .infinity)
            .background(Color(nsColor: .controlBackgroundColor))
            .cornerRadius(12)
            .shadow(radius: 1)
        }
        .frame(maxWidth: .infinity)
        .onAppear { setupListener() }
        .onDisappear { listener?.remove() } // Add cleanup for the listener
    }

    private func setupListener() {
        listener?.remove() // Prevent duplicate listeners
        
        let db = Firestore.firestore()
        
        // FIX: This now listens for real-time updates on the top-level /tourCrew collection
        // and filters for the current tourID.
        listener = db.collection("tourCrew")
            .whereField("tourId", isEqualTo: tourID)
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error loading crew: \(error?.localizedDescription ?? "Unknown")")
                    return
                }
                
                // We use Codable to automatically decode into our new TourCrew model.
                self.crewMembers = documents.compactMap { try? $0.data(as: TourCrew.self) }
            }
    }
}
import SwiftUI
import FirebaseFirestore

struct TourDetailView: View {
    var tour: Tour
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss

    var body: some View {
        ScrollView {
            VStack(spacing: 32) {
                TourHeaderView(tour: tour)
                
                TourSummaryCardsView(tourID: tour.id ?? "", ownerUserID: tour.ownerId)
                    .environmentObject(appState)
                
                HStack(alignment: .firstTextBaseline, spacing: 24) {
                    
                    TourItineraryView(tour: tour)
                    .frame(height: 500)

                    ScrollView {
                        VStack(spacing: 24) {
                            TourCrewView(
                                tourID: tour.id ?? "",
                                ownerUserID: tour.ownerId
                            )
                            
                            // FIX: This call is now corrected.
                            // It only passes the tourID, matching the new TourFlightsView.
                            TourFlightsView(
                                tourID: tour.id ?? ""
                            )
                        }
                        .padding()
                    }
                    .frame(height: 500)
                }

                if let tourID = tour.id {
                    ShowGridView(
                        tourID: tourID,
                        ownerUserID: tour.ownerId,
                        artistName: tour.artist,
                        onShowSelected: { selectedShow in
                            appState.selectedShow = selectedShow
                        }
                    )
                }
            }
            .padding(.horizontal, 24)
            .padding(.vertical)
        }
        .ignoresSafeArea(edges: .bottom)
    }
}
import SwiftUI

struct TokenInputView: View {
    @Binding var selectedTokens: [String]
    var allOptions: [String]
    var placeholder: String

    @State private var text: String = ""
    @FocusState private var isFocused: Bool

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            WrapView(items: selectedTokens) { token in
                HStack(spacing: 4) {
                    Text(token)
                        .font(.caption)
                        .padding(.horizontal, 10)
                        .padding(.vertical, 6)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(6)

                    Button(action: {
                        selectedTokens.removeAll { $0 == token }
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.caption)
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }

            TextField(placeholder, text: $text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .focused($isFocused)
                .onChange(of: text) { newValue in
                    let match = allOptions.first(where: {
                        $0.lowercased().hasPrefix(newValue.lowercased())
                            && !selectedTokens.contains($0)
                    })

                    if let match = match, newValue.count > 2 {
                        selectedTokens.append(match)
                        text = ""
                    }
                }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct AddCrewSectionView: View {
    let tourID: String
    @EnvironmentObject var appState: AppState

    // FIX: The State variable now uses our new, Codable TourCrew model.
    @State private var crewMembers: [TourCrew] = []
    @State private var newCrewName: String = ""
    @State private var newCrewEmail: String = ""
    @State private var roleInput: String = ""
    @State private var selectedRoles: [String] = []
    @State private var showRoleSuggestions: Bool = false
    @State private var selectedVisibility: String = "full"
    @State private var showVisibilityOptions: Bool = false

    @State private var emailValidationState: EmailValidationState = .none
    @State private var emailCheckTask: Task<Void, Never>? = nil
    
    // This will hold the listener so we can detach it when the view disappears.
    @State private var listener: ListenerRegistration?

    private enum EmailValidationState { case none, checking, valid, invalid }

    @State private var roleOptions: [String] = [
        "Lead Artist", "Support Artist", "DJ", "Dancer", "Guest Performer", "Musician",
        "Content", "Tour Manager", "Artist Manager", "Road Manager", "Assistant Manager",
        "Tour Accountant", "Advance Coordinator", "Production Manager", "Stage Manager",
        "Lighting", "Sound", "Audio Tech", "Video", "Playback Operator", "Backline Tech",
        "Rigger", "SFX", "Driver", "Transport Coordinator", "Logistics", "Fly Tech",
        "Local Runner", "Security", "Assistant", "Stylist", "Hair and Makeup", "Catering",
        "Merch Manager", "Wellness", "PA", "Childcare", "Label Rep", "Marketing",
        "Street Team", "Promoter Rep", "Merch Staff", "Translator", "Drone Op",
        "Content Creator", "Custom"
    ]

    let visibilityOptions: [String] = ["full", "limited", "temporary"]

    var filteredRoles: [String] {
        guard !roleInput.isEmpty else { return [] }
        return roleOptions.filter {
            !$0.isEmpty && $0.lowercased().contains(roleInput.lowercased()) && !selectedRoles.contains($0)
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Add Crew").font(.headline)

            VStack(spacing: 16) {
                HStack(spacing: 12) {
                    CustomTextField(placeholder: "Name", text: $newCrewName)
                    HStack(spacing: 8) {
                        CustomTextField(placeholder: "Email", text: $newCrewEmail)
                        switch emailValidationState {
                        case .checking:
                            ProgressView().scaleEffect(0.5)
                        case .valid:
                            Image(systemName: "checkmark.circle.fill").foregroundColor(.green)
                        default:
                            EmptyView().frame(width: 20)
                        }
                    }
                }
                .onChange(of: newCrewEmail) { _, newValue in
                    checkEmailWithDebounce(email: newValue)
                }

                VStack(spacing: 4) {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 6) {
                            ForEach(selectedRoles, id: \.self) { role in
                                HStack(spacing: 6) {
                                    Text(role).font(.subheadline)
                                    Button(action: { selectedRoles.removeAll { $0 == role } }) {
                                        Image(systemName: "xmark")
                                            .font(.system(size: 10, weight: .bold))
                                            .foregroundColor(.gray)
                                    }.buttonStyle(.plain)
                                }
                                .padding(.horizontal, 8).padding(.vertical, 4)
                                .background(Color.gray.opacity(0.2)).cornerRadius(6)
                            }
                            TextField("Type a role", text: $roleInput)
                                .textFieldStyle(PlainTextFieldStyle()).frame(minWidth: 100)
                                .onChange(of: roleInput) { _, value in
                                    showRoleSuggestions = !value.isEmpty
                                }.onSubmit { addCustomRole() }
                        }
                        .padding(.horizontal, 8).padding(.vertical, 6)
                    }
                    .frame(height: 42).background(Color.gray.opacity(0.05)).cornerRadius(8)

                    ZStack {
                        if showRoleSuggestions && !filteredRoles.isEmpty {
                            VStack(spacing: 0) {
                                ForEach(filteredRoles.prefix(5), id: \.self) { suggestion in
                                    Button(action: {
                                        selectedRoles.append(suggestion)
                                        roleInput = ""
                                        showRoleSuggestions = false
                                    }) {
                                        Text(suggestion)
                                            .frame(maxWidth: .infinity, alignment: .leading).padding(8)
                                    }.buttonStyle(.plain)
                                }
                            }
                            .background(Color(NSColor.windowBackgroundColor)).cornerRadius(6).shadow(radius: 1).padding(.top, 4)
                        }
                    }
                }

                VStack(alignment: .leading, spacing: 8) {
                    Text("Visibility").font(.subheadline).bold()
                    VStack(spacing: 0) {
                        Button(action: { withAnimation { showVisibilityOptions.toggle() } }) {
                            HStack {
                                Text(visibilityTitle(for: selectedVisibility))
                                    .font(.subheadline).foregroundColor(.primary)
                                Spacer()
                                Image(systemName: showVisibilityOptions ? "chevron.up" : "chevron.down")
                                    .font(.system(size: 12, weight: .bold)).foregroundColor(.gray)
                            }
                            .padding(.horizontal, 12).padding(.vertical, 12)
                            .background(Color.gray.opacity(0.05)).cornerRadius(8)
                        }.frame(width: 200)

                        if showVisibilityOptions {
                            VStack(spacing: 0) {
                                ForEach(visibilityOptions, id: \.self) { option in
                                    Button(action: {
                                        selectedVisibility = option
                                        showVisibilityOptions = false
                                    }) {
                                        Text(visibilityTitle(for: option))
                                            .padding(.vertical, 12).padding(.horizontal, 12)
                                            .frame(maxWidth: .infinity, alignment: .leading)
                                    }
                                    .buttonStyle(.plain).foregroundColor(.primary)
                                }
                            }
                            .background(Color(NSColor.windowBackgroundColor)).cornerRadius(8).shadow(radius: 2).padding(.top, 4)
                        }
                    }
                    Text(visibilityDescription(for: selectedVisibility))
                        .font(.footnote).foregroundColor(.gray).lineLimit(3)
                        .multilineTextAlignment(.leading).frame(maxWidth: .infinity, alignment: .leading)
                }
                Button(action: { saveCrewMember() }) {
                    HStack {
                        Image(systemName: "plus")
                        Text("Add Crew Member")
                    }
                }.font(.subheadline)
            }

            // This is the list that provides the visual confirmation.
            VStack(alignment: .leading, spacing: 8) {
                // FIX: This now iterates over the new [TourCrew] model.
                ForEach(crewMembers) { member in
                    VStack(alignment: .leading) {
                        Text("\(member.name) • \(member.roles.joined(separator: ", "))").font(.subheadline)
                        if let email = member.email, !email.isEmpty {
                            Text(email).font(.caption).foregroundColor(.gray)
                        }
                    }
                    .padding(8).background(Color.gray.opacity(0.05)).cornerRadius(8)
                }
            }
        }
        .padding(.top, 12)
        .onAppear { loadCrew() }
        .onDisappear { listener?.remove() } // Make sure to clean up the listener
    }

    private func checkEmailWithDebounce(email: String) {
        emailCheckTask?.cancel()
        let trimmedEmail = email.trimmingCharacters(in: .whitespaces).lowercased()
        guard !trimmedEmail.isEmpty, trimmedEmail.contains("@") else {
            emailValidationState = .none
            return
        }
        emailValidationState = .checking
        emailCheckTask = Task {
            do {
                try await Task.sleep(nanoseconds: 500_000_000)
                guard !Task.isCancelled else { return }
                FirebaseUserService.shared.checkUserExists(byEmail: trimmedEmail) { foundUserID in
                    DispatchQueue.main.async {
                        self.emailValidationState = (foundUserID != nil) ? .valid : .invalid
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    self.emailValidationState = .none
                }
            }
        }
    }

    private func visibilityTitle(for option: String) -> String {
        switch option {
        case "full": return "Full"
        case "limited": return "Limited"
        case "temporary": return "Temporary"
        default: return option
        }
    }

    private func visibilityDescription(for option: String) -> String {
        let name = newCrewName.isEmpty ? "They" : newCrewName
        switch option {
        case "full": return "\(name) can see the full itinerary. Best for core crew, admins, and agents."
        case "limited": return "\(name) can see most details. Good for production and show crew."
        case "temporary": return "\(name) can see show times and assigned items only. Best for support acts and one-offs."
        default: return ""
        }
    }

    private func addCustomRole() {
        let trimmedRole = roleInput.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedRole.isEmpty else { return }
        if !roleOptions.contains(trimmedRole) {
            roleOptions.append(trimmedRole)
        }
        selectedRoles.append(trimmedRole)
        roleInput = ""
        showRoleSuggestions = false
    }

    private func saveCrewMember() {
        guard !newCrewName.isEmpty, !selectedRoles.isEmpty, let ownerId = appState.userID else { return }
        let newCrew = TourCrew(
            tourId: self.tourID,
            userId: nil,
            contactId: nil,
            name: newCrewName.trimmingCharacters(in: .whitespaces),
            email: newCrewEmail.trimmingCharacters(in: .whitespaces).lowercased(),
            roles: selectedRoles,
            visibility: TourCrew.CrewVisibility(rawValue: selectedVisibility) ?? .full,
            invitedBy: ownerId
        )
        do {
            _ = try Firestore.firestore().collection("tourCrew").addDocument(from: newCrew)
            newCrewName = ""; newCrewEmail = ""; roleInput = ""; selectedRoles = []; selectedVisibility = "full"
        } catch {
            print("❌ Error saving new crew member: \(error.localizedDescription)")
        }
    }
    
    // --- FIX IS HERE ---
    private func loadCrew() {
        listener?.remove() // Prevent duplicate listeners
        let db = Firestore.firestore()
        
        // This now listens for real-time updates on the top-level /tourCrew collection
        // and filters for the current tour. This will make the list update instantly.
        listener = db.collection("tourCrew")
            .whereField("tourId", isEqualTo: tourID)
            .order(by: "createdAt", descending: true)
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error loading crew: \(error?.localizedDescription ?? "Unknown")")
                    return
                }
                // We use Codable to automatically decode into our new TourCrew model.
                self.crewMembers = documents.compactMap { try? $0.data(as: TourCrew.self) }
            }
    }
}
import SwiftUI
import FirebaseFirestore

struct DBAddVenueView: View {
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject var appState: AppState

    @State private var name: String = ""
    @State private var address: String = ""
    @State private var city: String = ""
    @State private var country: String = ""
    @State private var capacity: String = ""
    @State private var contactName: String = ""
    @State private var contactEmail: String = ""
    @State private var contactPhone: String = ""
    @State private var notes: String = ""
    
    @State private var isSaving = false

    private var isFormValid: Bool {
        !name.trimmingCharacters(in: .whitespaces).isEmpty &&
        !city.trimmingCharacters(in: .whitespaces).isEmpty
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            // Header
            HStack {
                Text("Add New Venue")
                    .font(.largeTitle.bold())
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title)
                        .foregroundColor(.gray.opacity(0.5))
                }
                .buttonStyle(.plain)
            }
            .padding(.bottom, 16)

            // Form Fields
            VStack(spacing: 16) {
                HStack {
                    StyledInputField(placeholder: "Venue Name*", text: $name)
                    StyledInputField(placeholder: "City*", text: $city)
                }
                HStack {
                    StyledInputField(placeholder: "Country", text: $country)
                    StyledInputField(placeholder: "Capacity", text: $capacity) // REMOVED: .keyboardType(.numberPad)
                }
                StyledInputField(placeholder: "Address", text: $address)
                
                Divider().padding(.vertical, 8)
                
                HStack {
                    StyledInputField(placeholder: "Contact Name", text: $contactName)
                    StyledInputField(placeholder: "Contact Email", text: $contactEmail)
                }
                StyledInputField(placeholder: "Contact Phone", text: $contactPhone)
            }
            
            Spacer()

            // Save Button
            Button(action: saveVenue) {
                HStack {
                    if isSaving {
                        ProgressView().colorInvert()
                    } else {
                        Text("Save Venue")
                    }
                }
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity)
                .padding()
                .background(isFormValid ? Color.accentColor : Color.gray.opacity(0.5))
                .foregroundColor(.white)
                .cornerRadius(12)
            }
            .buttonStyle(.plain)
            .disabled(!isFormValid || isSaving)
        }
        .padding(32)
        .frame(minWidth: 500, minHeight: 600)
    }
    
    private func saveVenue() {
        guard let userID = appState.userID else {
            print("Error: User ID is nil. Cannot save venue.")
            return
        }
        
        isSaving = true
        
        let db = Firestore.firestore()
        let collectionRef = db.collection("users").document(userID).collection("venues")
        
        let newVenueData: [String: Any] = [
            "name": name.trimmingCharacters(in: .whitespaces),
            "address": address.trimmingCharacters(in: .whitespaces),
            "city": city.trimmingCharacters(in: .whitespaces),
            "country": country.trimmingCharacters(in: .whitespaces),
            "capacity": Int(capacity) ?? 0,
            "contactName": contactName.trimmingCharacters(in: .whitespaces),
            "contactEmail": contactEmail.trimmingCharacters(in: .whitespaces),
            "contactPhone": contactPhone.trimmingCharacters(in: .whitespaces),
            "createdAt": Timestamp(date: Date())
        ]
        
        collectionRef.addDocument(data: newVenueData) { error in
            isSaving = false
            if let error = error {
                print("Error saving venue: \(error.localizedDescription)")
            } else {
                print("Venue saved successfully.")
                dismiss()
            }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct SetlistView: View {
    @EnvironmentObject var appState: AppState
    let tourID: String
    let showID: String
    let ownerUserID: String
    
    @State private var setlistItems: [SetlistItem] = []
    @State private var listener: ListenerRegistration?
    
    @State private var itemToEdit: SetlistItem?
    @State private var itemForNotes: SetlistItem?
    
    @State private var isEditing = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            header
            
            if setlistItems.isEmpty {
                placeholderView
            } else {
                list
            }
        }
        .onAppear(perform: setupListener)
        .onDisappear { listener?.remove() }
        .sheet(item: $itemToEdit) { item in
            // This binding logic finds the item in our local array to edit.
            // If it's a new item, it creates a temporary binding.
            let binding = Binding<SetlistItem>(
                get: {
                    if let index = setlistItems.firstIndex(where: { $0.id == item.id }) {
                        return setlistItems[index]
                    }
                    return item // For a new item not yet in the array
                },
                set: { updatedItem in
                    if let index = setlistItems.firstIndex(where: { $0.id == updatedItem.id }) {
                        setlistItems[index] = updatedItem
                    } else {
                        itemToEdit = updatedItem // Update the temporary state for a new item
                    }
                }
            )
            
            AddEditSetlistItemView(
                item: binding,
                onSave: { finalItem in
                    // --- FIX IS HERE ---
                    // First, save to the database.
                    SetlistService.shared.saveItem(finalItem)
                    
                    // Second, update our local array immediately for an instant UI refresh.
                    if let index = setlistItems.firstIndex(where: { $0.id == finalItem.id }) {
                        // If it's an existing item, update it.
                        setlistItems[index] = finalItem
                    } else {
                        // If it's a new item, append it.
                        setlistItems.append(finalItem)
                    }
                },
                onDelete: {
                    if let index = setlistItems.firstIndex(where: { $0.id == item.id }) {
                        deleteItem(at: index)
                    }
                }
            )
        }
        .sheet(item: $itemForNotes) { item in
            SetlistNotesView(item: item)
                .environmentObject(appState)
        }
        .animation(.default, value: setlistItems)
    }
    
    private var header: some View {
        HStack {
            Text("Setlist").font(.headline)
            Spacer()
            
            Button(isEditing ? "Done" : "Reorder") {
                isEditing.toggle()
            }
            .buttonStyle(.plain)
            
            Button(action: addItem) {
                Image(systemName: "plus.circle.fill").font(.title2)
            }
            .buttonStyle(.plain)
            .padding(.leading, 8)
        }
    }
    
    private var placeholderView: some View {
        Text("No Setlist Items. Add a song or marker to get started.")
            .foregroundColor(.secondary)
            .padding(40)
            .frame(maxWidth: .infinity)
            .background(Color(nsColor: .controlBackgroundColor))
            .cornerRadius(12)
    }

    private var list: some View {
        List {
            ForEach(setlistItems) { item in
                SetlistCardView(item: item) {
                    self.itemForNotes = item
                }
                .listRowSeparator(.hidden)
                .listRowBackground(Color.clear)
                .padding(.vertical, 2)
                .swipeActions(edge: .leading, allowsFullSwipe: true) {
                    Button { itemToEdit = item } label: { Label("Edit", systemImage: "pencil") }.tint(.blue)
                }
                .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                    Button(role: .destructive) { deleteItem(at: item) } label: { Label("Delete", systemImage: "trash") }
                }
            }
            .onMove(perform: isEditing ? moveItems : nil)
        }
        .listStyle(.plain)
        .background(Color.clear)
    }

    // MARK: - Data Functions
    
    private func setupListener() {
        listener?.remove()
        listener = SetlistService.shared.addListener(forShow: showID) { fetchedItems in
            // The listener will keep our data in sync with the database.
            self.setlistItems = fetchedItems
        }
    }
    
    private func addItem() {
        let newItem = SetlistItem(
            id: UUID().uuidString,
            showId: self.showID,
            tourId: self.tourID,
            order: setlistItems.count,
            type: .song,
            songTitle: ""
        )
        self.itemToEdit = newItem
    }
    
    private func moveItems(from source: IndexSet, to destination: Int) {
        var revisedItems = setlistItems
        revisedItems.move(fromOffsets: source, toOffset: destination)
        
        for (index, item) in revisedItems.enumerated() {
            revisedItems[index].order = index
        }
        
        SetlistService.shared.updateOrder(for: revisedItems)
    }
    
    private func deleteItem(at item: SetlistItem) {
        guard let itemID = item.id else { return }
        SetlistService.shared.deleteItem(itemID)
    }
    
    private func deleteItem(at index: Int) {
        let item = setlistItems[index]
        deleteItem(at: item)
    }
}
import SwiftUI
import FirebaseFirestore

struct ContactAddView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss

    // The state holds a temporary, blank contact object for the form to fill.
    @State private var newContact = Contact(ownerId: "", name: "", roles: [])
    @State private var isSaving = false
    
    var onContactAdded: () -> Void

    private var isFormValid: Bool {
        !newContact.name.trimmingCharacters(in: .whitespaces).isEmpty
    }

    var body: some View {
        VStack(spacing: 0) {
            HStack {
                Text("Add New Contact")
                    .font(.largeTitle.bold())
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.gray)
                }
                .buttonStyle(.plain)
            }
            .padding(32)

            ScrollView {
                // The ContactFormBody correctly binds to our temporary newContact state.
                ContactFormBody(contact: $newContact, isDisabled: false)
                    .padding(.horizontal, 32)
            }

            VStack(spacing: 0) {
                Divider()
                HStack {
                    Button(action: {
                        saveContact()
                    }) {
                        HStack {
                            Spacer()
                            if isSaving {
                                ProgressView()
                            } else {
                                Text("Save Contact")
                            }
                            Spacer()
                        }
                        .fontWeight(.bold)
                        .padding()
                        .background(isFormValid ? Color.accentColor : Color.gray)
                        .foregroundColor(.white)
                        .cornerRadius(12)
                    }
                    .buttonStyle(.plain)
                    .disabled(!isFormValid || isSaving)
                }
                .padding(.horizontal, 32)
                .padding(.vertical, 16)
            }
            .background(Material.bar)
        }
        .frame(width: 680, height: 750)
    }
    
    // --- FIX IS HERE ---
    private func saveContact() {
        guard let userID = appState.userID else {
            print("Error: User ID is nil. Cannot save contact.")
            return
        }
        guard isFormValid else { return }
        
        isSaving = true
        
        // Create a new, final Contact object with the correct ownerId from the AppState.
        // This respects the 'let' constant nature of the property.
        let contactToSave = Contact(
            ownerId: userID,
            name: newContact.name.trimmingCharacters(in: .whitespaces),
            roles: newContact.roles,
            email: newContact.email,
            phone: newContact.phone,
            notes: newContact.notes,
            location: newContact.location,
            profileImageURL: newContact.profileImageURL,
            dateOfBirth: newContact.dateOfBirth,
            countryOfBirth: newContact.countryOfBirth,
            passport: newContact.passport,
            documents: newContact.documents,
            emergencyContact: newContact.emergencyContact,
            allergies: newContact.allergies,
            medications: newContact.medications
        )
        
        let db = Firestore.firestore()
        
        do {
            // Use Codable to save the new object directly to the top-level /contacts collection
            try db.collection("contacts").addDocument(from: contactToSave) { error in
                self.isSaving = false
                if let error = error {
                    print("Error saving contact: \(error.localizedDescription)")
                } else {
                    print("✅ Contact saved successfully.")
                    self.onContactAdded()
                    self.dismiss()
                }
            }
        } catch {
            print("❌ Error encoding contact for save: \(error.localizedDescription)")
            self.isSaving = false
        }
    }
}
import SwiftUI
import Combine
import FirebaseFirestore // Import for Timestamp

struct SignInDynamicContentView: View {
    @Environment(\.colorScheme) var colorScheme
    @State private var initialDate = Date()

    var body: some View {
        GeometryReader { proxy in
            ZStack {
                backgroundGradient
                auroraView(proxy: proxy)
                floatingShapes(proxy: proxy)
                
                TimelineView(.animation(minimumInterval: 0.016, paused: false)) { context in
                    let elapsedTime = context.date.timeIntervalSince(initialDate)
                    cardStack(proxy: proxy, elapsedTime: elapsedTime)
                }
            }
            .clipShape(Rectangle())
            .overlay(alignment: .leading) {
                textOverlay()
            }
        }
        .onAppear {
            initialDate = Date()
        }
    }
    
    // MARK: - View Layers
    
    private var backgroundGradient: some View {
        let colors: [Color] = colorScheme == .dark
            ? [Color(red: 25/255, green: 30/255, blue: 35/255), Color(red: 15/255, green: 20/255, blue: 25/255)]
            : [Color(red: 240/255, green: 245/255, blue: 250/255), Color(red: 220/255, green: 225/255, blue: 235/255)]
        
        return LinearGradient(gradient: Gradient(colors: colors), startPoint: .topLeading, endPoint: .bottomTrailing)
            .ignoresSafeArea()
    }
    
    private func auroraView(proxy: GeometryProxy) -> some View {
        TimelineView(.animation(minimumInterval: 0.02, paused: false)) { context in
            let time = context.date.timeIntervalSinceReferenceDate
            ZStack {
                auroraShape(proxy: proxy, time: time, hue: 0.7, offsetX: -0.2, offsetY: -0.3, speed: 0.08, size: 0.6)
                auroraShape(proxy: proxy, time: time, hue: 0.5, offsetX: 0.3, offsetY: 0.3, speed: 0.06, size: 0.8)
                auroraShape(proxy: proxy, time: time, hue: 0.1, offsetX: 0.2, offsetY: -0.2, speed: 0.05, size: 0.5)
            }
            .blendMode(.plusLighter)
        }
    }
    
    private func auroraShape(proxy: GeometryProxy, time: TimeInterval, hue: Double, offsetX: Double, offsetY: Double, speed: Double, size: Double) -> some View {
        Circle()
            .fill(
                Color(hue: (sin(time * speed) + 1) / 2 * 0.2 + hue, saturation: 0.7, brightness: 0.8)
            )
            .frame(width: proxy.size.width * size, height: proxy.size.width * size)
            .offset(x: cos(time * speed * 1.2) * proxy.size.width * offsetX, y: sin(time * speed * 1.5) * proxy.size.height * offsetY)
            .blur(radius: 120)
    }
    
    private func floatingShapes(proxy: GeometryProxy) -> some View {
        ZStack {
            Circle().fill(Color.accentColor.opacity(0.3)).frame(width: proxy.size.width * 0.2, height: proxy.size.width * 0.2).offset(x: -proxy.size.width * 0.25, y: -proxy.size.height * 0.3).blur(radius: 80)
            Capsule().fill(Color.purple.opacity(0.3)).frame(width: proxy.size.width * 0.3, height: proxy.size.width * 0.15).offset(x: proxy.size.width * 0.28, y: proxy.size.height * 0.25).blur(radius: 90)
        }
    }

    private func cardStack(proxy: GeometryProxy, elapsedTime: TimeInterval) -> some View {
        let laneData: [(yOffset: CGFloat, speed: Double, reversed: Bool, cards: [AnyView])] = [
            (yOffset: -210, speed: 65, reversed: false, cards: [
                AnyView(InteractiveCard(zPosition: 0) { PlaceholderFlightCard(flight: DummySignInData.nzFlight) }),
                AnyView(InteractiveCard(zPosition: -0.8) { PlaceholderItineraryCard(item: DummySignInData.lobbyCall) }),
                AnyView(InteractiveCard(zPosition: -1.6) { PlaceholderVenueCard(venue: DummySignInData.venue) })
            ]),
            (yOffset: -70, speed: 80, reversed: false, cards: [
                AnyView(InteractiveCard(zPosition: -0.5) { PlaceholderItineraryCard(item: DummySignInData.interview) }),
                AnyView(InteractiveCard(zPosition: -1.4) { PlaceholderItineraryCard(item: DummySignInData.hiltonCheckin) }),
                AnyView(InteractiveCard(zPosition: -1.0) { PlaceholderFlightCard(flight: DummySignInData.uaFlight) }),
                AnyView(InteractiveCard(zPosition: -1.8) { PlaceholderContactCard(contact: DummySignInData.tourManager) })
            ]),
            (yOffset: 70, speed: 55, reversed: false, cards: [
                AnyView(InteractiveCard(zPosition: -0.6) { PlaceholderFlightCard(flight: DummySignInData.qfFlight) }),
                AnyView(InteractiveCard(zPosition: -1.0) { PlaceholderItineraryCard(item: DummySignInData.soundcheck) }),
                AnyView(InteractiveCard(zPosition: -0.4) { PlaceholderItineraryCard(item: DummySignInData.dinner) })
            ]),
            (yOffset: 210, speed: 70, reversed: false, cards: [
                AnyView(InteractiveCard(zPosition: -0.2) { PlaceholderFlightCard(flight: DummySignInData.aaFlight) }),
                AnyView(InteractiveCard(zPosition: -1.2) { PlaceholderFlightCard(flight: DummySignInData.ekFlight) }),
                AnyView(InteractiveCard(zPosition: -0.7) { PlaceholderItineraryCard(item: DummySignInData.dayOff) }),
                AnyView(InteractiveCard(zPosition: -1.2) { PlaceholderFlightCard(flight: DummySignInData.sqFlight) })
            ])
        ]
        
        return ZStack {
            ForEach(laneData.indices, id: \.self) { index in
                LaneView(
                    proxy: proxy,
                    cards: laneData[index].cards,
                    yOffset: laneData[index].yOffset,
                    speed: laneData[index].speed,
                    zPosition: CGFloat(index)
                )
            }
        }
    }

    private func textOverlay() -> some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack(spacing: 0) {
                Text("YOUR ")
                    .font(.system(size: 24, weight: .bold))
                
                TypingEffectTextView(words: ["TOUR", "SHOW", "FLIGHTS", "ITINERARY", "HOTEL", "CREW", "GUEST LIST"])
                    .font(.system(size: 24, weight: .bold))
            }
            .foregroundColor(.secondary)
            
            Text("MANAGED")
                .font(.system(size: 48, weight: .bold))
                .kerning(-1)
                .foregroundColor(.primary)
                .padding(.bottom, 8)
            
            Text("Plan, manage, and track every detail—without the chaos.")
                .font(.title3)
                .foregroundColor(.secondary)
                .lineSpacing(6)
                .frame(maxWidth: 400, alignment: .leading)
        }
        .padding(60)
        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
        .allowsHitTesting(false)
    }
}

// MARK: - Animation and Helper Views

fileprivate struct LaneView: View {
    let proxy: GeometryProxy
    @State private var elapsedTime: Double = 0.0
    
    let cards: [AnyView]
    let yOffset: CGFloat
    let speed: Double
    let zPosition: CGFloat
    
    var body: some View {
        TimelineView(.animation(minimumInterval: 0.016, paused: false)) { context in
            let cardSpacing: CGFloat = 450
            let cardWidth: CGFloat = 300
            let laneContentWidth = CGFloat(cards.count) * (cardWidth + cardSpacing)
            
            let duplicatedCards = HStack(spacing: cardSpacing) {
                ForEach(0..<cards.count, id: \.self) { i in cards[i] }
                ForEach(0..<cards.count, id: \.self) { i in cards[i] }
            }
            
            let loopingX = (elapsedTime * speed).truncatingRemainder(dividingBy: laneContentWidth)
            
            duplicatedCards
                .offset(x: -loopingX)
                .offset(y: yOffset)
                .zIndex(zPosition)
                .onAppear { elapsedTime = context.date.timeIntervalSinceReferenceDate }
                .onChange(of: context.date) { _,_ in // Updated for new onChange signature
                    elapsedTime += 0.016
                }
        }
    }
}


fileprivate struct InteractiveCard<Content: View>: View {
    let zPosition: CGFloat
    let content: Content
    
    @State private var isHovered = false
    
    init(zPosition: CGFloat, @ViewBuilder content: () -> Content) {
        self.zPosition = zPosition
        self.content = content()
    }
    
    var body: some View {
        let baseScale = 1.0 + (zPosition * 0.05)
        let hoverScale = isHovered ? 1.05 : 1.0
        let baseBlurRadius = max(0, -zPosition * 1.5)
        
        content
            .scaleEffect(baseScale * hoverScale)
            .blur(radius: isHovered ? 0 : baseBlurRadius)
            .zIndex(isHovered ? 100 : zPosition)
            .contentShape(Rectangle())
            .onHover { hovering in
                withAnimation(.easeOut(duration: 0.35)) {
                    isHovered = hovering
                }
            }
    }
}

fileprivate struct TypingEffectTextView: View {
    let words: [String]
    
    @State private var currentWordIndex = 0
    @State private var visibleCharacters = 0
    @State private var state: TypingState = .typing
    @State private var pauseCounter = 0
    
    private enum TypingState { case typing, paused, deleting }
    private let typingDelay = 0.12
    private let pauseTicks = 15
    
    let timer = Timer.publish(every: 0.1, on: .main, in: .common).autoconnect()

    var body: some View {
        Text(String(words[currentWordIndex].prefix(visibleCharacters)))
            .frame(width: 250, alignment: .leading)
            .onReceive(timer) { _ in
                animateText()
            }
    }
    
    private func animateText() {
        switch state {
        case .typing:
            if visibleCharacters < words[currentWordIndex].count {
                visibleCharacters += 1
            } else {
                state = .paused
            }
        case .paused:
            if pauseCounter < pauseTicks {
                pauseCounter += 1
            } else {
                pauseCounter = 0
                state = .deleting
            }
        case .deleting:
            if visibleCharacters > 0 {
                visibleCharacters -= 1
            } else {
                state = .typing
                currentWordIndex = (currentWordIndex + 1) % words.count
            }
        }
    }
}


// MARK: - Dummy Data and Placeholder Views

fileprivate enum DummySignInData {
    private static func time(hour: Int, minute: Int) -> Date { Calendar.current.date(bySettingHour: hour, minute: minute, second: 0, of: Date()) ?? Date() }
    
    // FIX: Updated to create instances of the new 'Flight' model.
    static let nzFlight = Flight(tourId: "d1", airline: "Air New Zealand", flightNumber: "NZ102", departureTimeUTC: Timestamp(date: time(hour: 8, minute: 0)), arrivalTimeUTC: Timestamp(date: time(hour: 11, minute: 30)), origin: "AKL", destination: "SYD", passengers: [])
    static let aaFlight = Flight(tourId: "d2", airline: "American Airlines", flightNumber: "AA118", departureTimeUTC: Timestamp(date: time(hour: 18, minute: 30)), arrivalTimeUTC: Timestamp(date: time(hour: 23, minute: 50)), origin: "LAX", destination: "JFK", passengers: [])
    static let qfFlight = Flight(tourId: "d3", airline: "Qantas", flightNumber: "QF44", departureTimeUTC: Timestamp(date: time(hour: 10, minute: 0)), arrivalTimeUTC: Timestamp(date: time(hour: 14, minute: 0)), origin: "SYD", destination: "LAX", passengers: [])
    static let sqFlight = Flight(tourId: "d4", airline: "Singapore Airlines", flightNumber: "SQ317", departureTimeUTC: Timestamp(date: time(hour: 23, minute: 0)), arrivalTimeUTC: Timestamp(date: time(hour: 5, minute: 0)), origin: "SIN", destination: "LHR", passengers: [])
    static let ekFlight = Flight(tourId: "d5", airline: "Emirates", flightNumber: "EK413", departureTimeUTC: Timestamp(date: time(hour: 10, minute: 50)), arrivalTimeUTC: Timestamp(date: time(hour: 18, minute: 20)), origin: "DXB", destination: "AKL", passengers: [])
    static let uaFlight = Flight(tourId: "d6", airline: "United Airlines", flightNumber: "UA90", departureTimeUTC: Timestamp(date: time(hour: 22, minute: 45)), arrivalTimeUTC: Timestamp(date: time(hour: 6, minute: 15)), origin: "SFO", destination: "SYD", passengers: [])
    
    static let hiltonCheckin = DummyItineraryItem(type: .hotel, title: "Check into Hilton", time: time(hour: 15, minute: 0), subtitle: "Room 1204")
    static let soundcheck = DummyItineraryItem(type: .mic, title: "Soundcheck", time: time(hour: 16, minute: 0), subtitle: "Spark Arena")
    static let lobbyCall = DummyItineraryItem(type: .travel, title: "Lobby Call", time: time(hour: 11, minute: 0), subtitle: "To Airport")
    static let dinner = DummyItineraryItem(type: .food, title: "Dinner Reservation", time: time(hour: 20, minute: 0), subtitle: "The French Cafe")
    static let interview = DummyItineraryItem(type: .promo, title: "Radio Interview", time: time(hour: 13, minute: 0), subtitle: "ZM Radio")
    static let dayOff = DummyItineraryItem(type: .dayOff, title: "Day Off", time: time(hour: 0, minute: 0), subtitle: "Explore the city")
    static let tourManager = DummyContactItem(name: "Alex Johnson", role: "Tour Manager")
    static let venue = DummyVenueItem(name: "Tuning Fork", city: "Auckland")
}

fileprivate enum DummyItineraryType {
    case hotel, mic, travel, food, promo, dayOff
    var iconName: String {
        switch self {
        case .hotel: return "bed.double.fill"
        case .mic: return "music.mic"
        case .travel: return "car.fill"
        case .food: return "fork.knife"
        case .promo: return "megaphone.fill"
        case .dayOff: return "sun.max.fill"
        }
    }
}
fileprivate struct DummyItineraryItem { let type: DummyItineraryType; let title: String; let time: Date; let subtitle: String? }
fileprivate struct DummyContactItem { let name: String; let role: String }
fileprivate struct DummyVenueItem { let name: String; let city: String }

fileprivate struct PlaceholderFlightCard: View {
    let flight: Flight
    private var airlineCode: String { String(flight.flightNumber?.prefix(2) ?? "") }
    private var isDarkTheme: Bool { airlineCode == "NZ" }
    private var isCustomColorTheme: Bool { airlineCode == "SQ" }
    private var logoName: String { isDarkTheme ? "\(airlineCode)_icon_light" : "\(airlineCode)_icon" }
    private var cardBackgroundColor: Color {
        if isDarkTheme { return Color.black.opacity(0.85) }
        if isCustomColorTheme { return Color(red: 38/255, green: 78/255, blue: 138/255) }
        return Color.white.opacity(0.85)
    }
    var body: some View {
        HStack(spacing: 16) {
            Image(logoName).resizable().aspectRatio(contentMode: .fit).frame(width: 44, height: 44)
            VStack(alignment: .leading, spacing: 2) {
                Text("\(flight.origin) → \(flight.destination)").font(.system(size: 20, weight: .bold))
                Text("\(flight.airline ?? "") \(flight.flightNumber ?? "")").font(.caption).opacity(0.8)
            }
            Spacer()
        }
        .padding().foregroundColor(isDarkTheme || isCustomColorTheme ? .white : .black).background(cardBackgroundColor.background(.ultraThinMaterial)).cornerRadius(16).frame(width: 300).shadow(color: .black.opacity(isDarkTheme || isCustomColorTheme ? 0.3 : 0.1), radius: 10)
    }
}
fileprivate struct PlaceholderItineraryCard: View {
    let item: DummyItineraryItem
    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: item.type.iconName).font(.title2.weight(.medium)).foregroundColor(.accentColor).frame(width: 30)
            VStack(alignment: .leading) {
                Text(item.title).fontWeight(.bold)
                if let subtitle = item.subtitle { Text(subtitle).font(.subheadline).foregroundColor(.secondary) }
            }
            Spacer()
            Text(item.time, style: .time).font(.subheadline).foregroundColor(.secondary)
        }
        .padding().background(.regularMaterial).cornerRadius(16).frame(width: 300).shadow(color: .black.opacity(0.2), radius: 8)
    }
}
fileprivate struct PlaceholderContactCard: View {
    let contact: DummyContactItem
    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: "person.text.rectangle.fill").font(.title2.weight(.medium)).foregroundColor(.accentColor).frame(width: 30)
            VStack(alignment: .leading) {
                Text(contact.name).fontWeight(.bold)
                Text(contact.role).font(.subheadline).foregroundColor(.secondary)
            }
            Spacer()
        }
        .padding().background(.regularMaterial).cornerRadius(16).frame(width: 300).shadow(color: .black.opacity(0.2), radius: 8)
    }
}
fileprivate struct PlaceholderVenueCard: View {
    let venue: DummyVenueItem
    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: "mappin.and.ellipse").font(.title2.weight(.medium)).foregroundColor(.accentColor).frame(width: 30)
            VStack(alignment: .leading) {
                Text(venue.name).fontWeight(.bold)
                Text(venue.city).font(.subheadline).foregroundColor(.secondary)
            }
            Spacer()
        }
        .padding().background(.regularMaterial).cornerRadius(16).frame(width: 300).shadow(color: .black.opacity(0.2), radius: 8)
    }
}
import SwiftUI

// This is a new, dedicated view for ADDING an item.
struct AddSetlistItemView: View {
    let tourID: String
    let showID: String
    let initialOrder: Int
    let onSave: (SetlistItem) -> Void
    @Environment(\.dismiss) var dismiss

    // The view manages its own state for the new item being created.
    @State private var newItem: SetlistItem

    init(tourID: String, showID: String, order: Int, onSave: @escaping (SetlistItem) -> Void) {
        self.tourID = tourID
        self.showID = showID
        self.initialOrder = order
        self.onSave = onSave
        
        // Create a new, blank item when the view appears.
        _newItem = State(initialValue: SetlistItem(
            id: UUID().uuidString, // Generate a client-side ID
            showId: showID,
            tourId: tourID,
            order: order,
            type: .song,
            songTitle: "New Song"
        ))
    }

    var body: some View {
        // We pass the binding to our local state item to the edit view.
        // This reuses the form UI, but for a new item.
        AddEditSetlistItemView(
            item: $newItem,
            onSave: { finalItem in
                // When "Save" is pressed in the form, we call the onSave closure
                // from the parent view (SetlistView) to save it to Firestore.
                onSave(finalItem)
            },
            onDelete: {
                // A new item can't be deleted, so this closure is empty.
            }
        )
    }
}
import SwiftUI
import FirebaseFirestore

struct ContactsTableView: View {
    // FIX: The view now accepts an array of our new 'Contact' model.
    let contacts: [Contact]
    @Binding var sortField: String
    @Binding var sortAscending: Bool
    
    // FIX: The closure now provides the new 'Contact' model.
    var onContactSelected: (Contact) -> Void

    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                // Header row remains the same
                HStack {
                    sortableHeader("Name")
                    sortableHeader("Role")
                    sortableHeader("Email")
                    sortableHeader("Phone")
                    sortableHeader("Notes")
                }
                .padding(.vertical, 8)
                Divider()

                // FIX: The ForEach now iterates directly over the sorted contacts array.
                // The complex merging logic has been removed.
                ForEach(sortedContacts) { contact in
                    Button(action: { onContactSelected(contact) }) {
                        HStack {
                            Text(contact.name).frame(maxWidth: .infinity, alignment: .leading)
                            Text(contact.roles.joined(separator: ", ")).frame(maxWidth: .infinity, alignment: .leading)
                            Text(contact.email ?? "").frame(maxWidth: .infinity, alignment: .leading)
                            Text(contact.phone ?? "").frame(maxWidth: .infinity, alignment: .leading)
                            Text(contact.notes ?? "").frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, 4)
                        .contentShape(Rectangle()) // Ensure the whole area is tappable
                    }
                    .buttonStyle(.plain)
                    Divider()
                }
            }
            .padding(.horizontal)
        }
    }

    // FIX: This computed property now sorts the new [Contact] array directly.
    private var sortedContacts: [Contact] {
        contacts.sorted { a, b in
            let comparison: Bool
            switch sortField {
            case "Name":
                comparison = a.name < b.name
            case "Role":
                comparison = a.roles.joined() < b.roles.joined()
            case "Email":
                comparison = (a.email ?? "") < (b.email ?? "")
            case "Phone":
                comparison = (a.phone ?? "") < (b.phone ?? "")
            default:
                comparison = a.name < b.name
            }
            return sortAscending ? comparison : !comparison
        }
    }

    private func sortableHeader(_ field: String) -> some View {
        Button(action: {
            if sortField == field {
                sortAscending.toggle()
            } else {
                sortField = field
                sortAscending = true
            }
        }) {
            HStack {
                Text(field).bold()
                if sortField == field {
                    Image(systemName: sortAscending ? "arrow.up" : "arrow.down")
                        .font(.caption)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .buttonStyle(.plain)
    }
}
import SwiftUI
import FirebaseFirestore
import FirebaseStorage
import AppKit
import UniformTypeIdentifiers

struct NewTourFlowView: View {
    @EnvironmentObject var appState: AppState
    @State private var tourName: String = ""
    @State private var artistName: String = ""
    @State private var startDate: Date = Date()
    @State private var endDate: Date = Date()
    @State private var tourScope: String = "national"
    @State private var posterImage: NSImage? = nil
    @State private var posterFileURL: URL? = nil
    
    // This now holds the complete new Tour object once saved
    @State private var newTour: Tour? = nil
    @State private var isSaving = false

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 32) {
                HStack(alignment: .top, spacing: 32) {
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Create New Tour").font(.system(size: 24, weight: .bold))
                        CustomTextField(placeholder: "Tour Name", text: $tourName)
                        CustomTextField(placeholder: "Artist Name", text: $artistName)
                        HStack(spacing: 12) {
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Start Date").font(.subheadline).foregroundColor(.gray)
                                CustomDateField(date: $startDate)
                            }
                            VStack(alignment: .leading, spacing: 4) {
                                Text("End Date").font(.subheadline).foregroundColor(.gray)
                                CustomDateField(date: $endDate)
                            }
                        }
                        Text("Including Travel/Extra Days").font(.footnote).foregroundColor(.gray)
                        Picker("", selection: $tourScope) {
                            Text("National").tag("national")
                            Text("International").tag("international")
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        .frame(height: 44)
                        Button(action: { Task { await saveTour() } }) {
                            Text(isSaving ? "Saving..." : "Continue")
                                .fontWeight(.semibold)
                                .frame(width: 200, height: 44)
                                .foregroundColor(.black)
                        }
                        .buttonStyle(PlainButtonStyle())
                        .background(Color.white)
                        .cornerRadius(8)
                        .disabled(tourName.isEmpty || artistName.isEmpty || isSaving)
                    }

                    VStack {
                        ZStack {
                            RoundedRectangle(cornerRadius: 10)
                                .fill(Color.gray.opacity(0.05))
                                .frame(width: 200, height: 240)
                            if let img = posterImage {
                                Image(nsImage: img)
                                    .resizable().scaledToFill().frame(width: 200, height: 240)
                                    .clipped().cornerRadius(10)
                            } else {
                                VStack(spacing: 8) {
                                    Image(systemName: "photo.on.rectangle.angled")
                                        .font(.system(size: 28)).foregroundColor(.gray)
                                    Text("Upload Tour Poster")
                                        .foregroundColor(.gray).font(.subheadline)
                                }
                            }
                        }
                        .onTapGesture { selectPoster() }
                    }
                    .padding(.top, 40)
                }

                // FIX: These 'if let' statements now correctly check for the 'newTour' state object.
                if let tour = newTour, let tourID = tour.id {
                    AddCrewSectionView(tourID: tourID)
                    Divider()
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Add Shows").font(.headline)
                        ShowGridView(
                            tourID: tourID,
                            ownerUserID: tour.ownerId,
                            artistName: tour.artist,
                            onShowSelected: { selectedShow in
                                appState.selectedShow = selectedShow
                            }
                        )
                        Spacer()
                    }
                    .padding()
                }
            }
            .padding(.leading, 20)
            .padding(.trailing, 20)
        }
    }

    private func selectPoster() {
        let panel = NSOpenPanel()
        panel.allowedContentTypes = [.png, .jpeg]
        panel.canChooseFiles = true
        panel.allowsMultipleSelection = false
        if panel.runModal() == .OK, let url = panel.url, let img = NSImage(contentsOf: url) {
            posterImage = img
            posterFileURL = url
        }
    }

    private func saveTour() async {
        guard let userID = appState.userID else { return }
        isSaving = true
        
        var posterURLString: String? = nil
        if let fileURL = posterFileURL {
            do {
                let storageRef = Storage.storage().reference().child("posters/\(UUID().uuidString).jpg")
                _ = try await storageRef.putFileAsync(from: fileURL, metadata: nil)
                let downloadURL = try await storageRef.downloadURL()
                posterURLString = downloadURL.absoluteString
            } catch {
                print("❌ Error uploading poster: \(error.localizedDescription)")
            }
        }
        
        var newTourData = Tour(
            ownerId: userID,
            tourName: tourName,
            artist: artistName,
            startDate: Timestamp(date: startDate),
            endDate: Timestamp(date: endDate),
            posterURL: posterURLString
        )

        do {
            let ref = try Firestore.firestore().collection("tours").addDocument(from: newTourData)
            newTourData.id = ref.documentID
            // This sets the state object that unhides the rest of the view
            self.newTour = newTourData
        } catch {
            print("❌ Error saving tour: \(error.localizedDescription)")
        }
        
        isSaving = false
    }
}
import SwiftUI

struct CustomDateInputView: View {
    let label: String
    @Binding var date: Date

    @State private var dateString: String = ""
    @State private var isPopoverPresented: Bool = false

    private static let formatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "dd/MM/yyyy"
        return formatter
    }()

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(label)
                .font(.subheadline)
                .foregroundColor(.gray)

            HStack(spacing: 0) {
                TextField(Self.formatter.dateFormat, text: $dateString)
                    .padding(12)
                    .textFieldStyle(PlainTextFieldStyle())
                    .onChange(of: dateString) { newValue in
                        // Attempt to parse the typed string into a date
                        if let newDate = Self.formatter.date(from: newValue) {
                            self.date = newDate
                        }
                    }
                
                Button(action: { isPopoverPresented = true }) {
                    Image(systemName: "calendar")
                        .foregroundColor(.gray)
                        .padding(.horizontal, 12)
                }
                .buttonStyle(.plain)
                .popover(isPresented: $isPopoverPresented) {
                    DatePicker("", selection: $date, displayedComponents: .date)
                        .datePickerStyle(.graphical)
                        .labelsHidden()
                        .onChange(of: date) { newDate in
                            // Update text field when popover date changes
                            self.dateString = Self.formatter.string(from: newDate)
                            isPopoverPresented = false
                        }
                }
            }
            .background(Color.gray.opacity(0.06))
            .cornerRadius(10)
            .onAppear {
                // Initialize the text field with the current date value
                self.dateString = Self.formatter.string(from: date)
            }
            .onChange(of: date) { newDate in
                // Keep text field in sync if the binding is changed externally
                let newDateString = Self.formatter.string(from: newDate)
                if newDateString != dateString {
                    dateString = newDateString
                }
            }
        }
    }
}
import SwiftUI
import MapKit
import FirebaseFirestore

struct ShowDetailView: View {
    let tour: Tour
    @State var show: Show

    @State private var mapRegion: MKCoordinateRegion = MKCoordinateRegion()
    @State private var mapItem: MKMapItem?
    @State private var guestList: [GuestListItemModel] = [] // This old model will be refactored later
    
    @State private var showAddGuest = false
    @State private var showEditShow = false
    @State private var showContactDetails = false

    @EnvironmentObject var appState: AppState

    init(tour: Tour, show: Show) {
        self.tour = tour
        self._show = State(initialValue: show)
    }

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 32) {
                headerSection
                Divider()
                
                HStack(alignment: .top, spacing: 16) {
                    VStack(alignment: .leading, spacing: 16) {
                        showTimingsPanel
                        // VenueNotesPanel has been temporarily removed until its data model is refactored.
                    }
                    .frame(minWidth: 0, maxWidth: .infinity)
                    
                    VStack(alignment: .leading, spacing: 16) {
                        guestListPanel
                        
                        SetlistView(
                            tourID: tour.id ?? "",
                            showID: show.id ?? "",
                            ownerUserID: tour.ownerId
                        )
                        .environmentObject(appState)
                    }
                    .frame(minWidth: 0, maxWidth: .infinity)
                }
            }
            .padding()
            .onAppear {
                loadMapForAddress()
                // FIX: Removed call to the old loadVenueNotes() function.
                loadGuestList()
            }
            .sheet(isPresented: $showAddGuest) {
                AddGuestView(userID: tour.ownerId, tourID: tour.id ?? "", showID: show.id ?? "") {
                    loadGuestList()
                }
            }
            .sheet(isPresented: $showEditShow) {
                ShowEditView(tour: tour, show: $show)
            }
        }
        .navigationTitle("Show Details")
    }

    private var headerSection: some View {
        let spacingDateToCity: CGFloat = 3
        let spacingCityToVenue: CGFloat = 3
        let spacingVenueToLoadIn: CGFloat = 7

        return VStack(alignment: .leading, spacing: 32) {
            GeometryReader { geo in
                let totalWidth = geo.size.width
                let mapWidth = max(min(800, totalWidth * 0.55), 320)
                let dynamicSpacing = max(12, totalWidth * 0.04)

                HStack(alignment: .top, spacing: dynamicSpacing) {
                    VStack(alignment: .leading, spacing: 0) {
                        HStack(spacing: 8) {
                            Button(action: {
                                appState.selectedShow = nil
                            }) {
                                HStack(spacing: 4) {
                                    Image(systemName: "chevron.left")
                                    Text("Back")
                                }
                                .font(.system(size: 13, weight: .medium)).foregroundColor(.primary)
                                .padding(.vertical, 4).padding(.horizontal, 10)
                                .background(Color.gray.opacity(0.2)).cornerRadius(6)
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                        Spacer().frame(height: spacingDateToCity)
                        Text(show.date.dateValue().formatted(date: .numeric, time: .omitted))
                            .font(.system(size: 16)).foregroundColor(.gray)
                        Spacer().frame(height: spacingDateToCity)
                        Text(show.city.uppercased())
                            .font(.system(size: 55, weight: .bold)).lineLimit(1).minimumScaleFactor(0.5)
                        Spacer().frame(height: spacingCityToVenue)
                        Text(show.venueName)
                            .font(.system(size: 22, weight: .medium)).foregroundColor(.gray)
                        Spacer().frame(height: spacingVenueToLoadIn)
                        if let loadInDate = show.loadIn?.dateValue() {
                            Label {
                                Text("Load In Time: \(loadInDate.formatted(date: .omitted, time: .shortened))")
                                    .font(.system(size: 13, weight: .semibold)).foregroundColor(.black)
                            } icon: {
                                Image(systemName: "truck")
                                    .font(.system(size: 13)).foregroundColor(.black)
                            }
                            .padding(.horizontal, 10).padding(.vertical, 6)
                            .background(Color.gray.opacity(0.15)).cornerRadius(6)
                        }
                    }
                    Spacer()
                    Map(coordinateRegion: $mapRegion, annotationItems: annotationItems()) { item in
                        MapMarker(coordinate: item.coordinate, tint: .red)
                    }
                    .cornerRadius(12).frame(width: mapWidth, height: 180)
                }
            }
            .frame(height: 200)

            HStack(alignment: .top, spacing: 40) {
                VStack(alignment: .leading, spacing: 16) {
                    HStack(spacing: 10) {
                        Image(systemName: "mappin.and.ellipse").font(.system(size: 18))
                        Button(action: openInMaps) {
                            Text(show.venueAddress).font(.system(size: 16))
                        }.buttonStyle(PlainButtonStyle())
                    }
                    HStack(spacing: 10) {
                        Image(systemName: "person.fill").font(.system(size: 18))
                        Text(show.contactName ?? "Venue Contact")
                            .font(.system(size: 16))
                            .onTapGesture { withAnimation { showContactDetails.toggle() } }
                        if showContactDetails {
                            if let email = show.contactEmail {
                                Text(email).font(.system(size: 14)).foregroundColor(.gray)
                            }
                            if let phone = show.contactPhone {
                                Text(phone).font(.system(size: 14)).foregroundColor(.gray)
                            }
                        }
                    }
                }
                Spacer()
                VStack(alignment: .trailing, spacing: 16) {
                    Button(action: { showEditShow = true }) {
                        Label("Edit Show", systemImage: "pencil")
                            .fontWeight(.semibold).frame(width: 220, height: 44).background(Color.blue.opacity(0.15)).foregroundColor(.blue).cornerRadius(10)
                    }.buttonStyle(.plain)
                    Button(action: {}) {
                        Label("Upload Documents", systemImage: "tray.and.arrow.up")
                            .fontWeight(.semibold).frame(width: 220, height: 44).background(Color.green.opacity(0.15)).foregroundColor(.green).cornerRadius(10)
                    }.buttonStyle(.plain)
                }
            }
            .frame(maxWidth: .infinity)
            .padding(.top, -12)
        }
    }

    private func openInMaps() {
        let searchRequest = MKLocalSearch.Request()
        searchRequest.naturalLanguageQuery = show.venueAddress
        let search = MKLocalSearch(request: searchRequest)
        search.start { response, _ in
            if let mapItem = response?.mapItems.first {
                mapItem.openInMaps()
            }
        }
    }

    private var showTimingsPanel: some View {
        VStack(alignment: .leading) {
            HStack { Text("Show Timings").font(.headline); Spacer() }.padding(.bottom, 4)
            VStack(alignment: .leading, spacing: 8) {
                timingRow("Load In", show.loadIn?.dateValue())
                timingRow("Soundcheck", show.soundCheck?.dateValue())
                timingRow("Doors", show.doorsOpen?.dateValue())
                timingRow("Headliner Set", show.headlinerSetTime?.dateValue())
                timingRow("Pack Out", show.packOut?.dateValue())
            }
            Spacer()
        }
        .frame(minHeight: 200).frame(maxWidth: .infinity).padding().background(Color(nsColor: .controlBackgroundColor)).cornerRadius(10)
    }

    private func timingRow(_ label: String, _ time: Date?) -> some View {
        HStack {
            Text(label).font(.subheadline)
            Spacer()
            if let time = time { Text(time.formatted(date: .omitted, time: .shortened)) }
            else { Text("-") }
        }
    }
    
    private var guestListPanel: some View {
        VStack(alignment: .leading) {
            HStack { Text("Guest List").font(.headline); Spacer(); Button(action: { showAddGuest = true }) { Image(systemName: "plus.circle.fill").font(.title3) }.buttonStyle(.plain) }
            if guestList.isEmpty {
                Text("No guests yet").foregroundColor(.secondary)
            } else {
                VStack(alignment: .leading, spacing: 8) {
                    ForEach(guestList) { guest in
                        VStack(alignment: .leading, spacing: 2) {
                            HStack {
                                Text(guest.name).font(.headline)
                                if let additional = guest.additionalGuests, !additional.isEmpty, additional != "0" {
                                    Text("+\(additional)").font(.subheadline).foregroundColor(.gray)
                                }
                            }
                            if let note = guest.note, !note.isEmpty {
                                Text(note).font(.subheadline).foregroundColor(.gray)
                            }
                        }
                    }
                }
            }
            Spacer()
        }
        .frame(minHeight: 200).frame(maxWidth: .infinity).padding().background(Color(nsColor: .controlBackgroundColor)).cornerRadius(10)
    }

    private func loadGuestList() {
        guard let showID = show.id else { return }
        let db = Firestore.firestore()
        db.collection("users").document(tour.ownerId).collection("tours").document(tour.id ?? "").collection("shows").document(showID).collection("guestlist")
            .getDocuments { snapshot, _ in
                self.guestList = snapshot?.documents.compactMap { GuestListItemModel(from: $0) } ?? []
            }
    }
    
    private func loadMapForAddress() {
        let searchRequest = MKLocalSearch.Request()
        searchRequest.naturalLanguageQuery = show.venueAddress
        let search = MKLocalSearch(request: searchRequest)
        search.start { response, error in
            guard let mapItem = response?.mapItems.first else { return }
            self.mapItem = mapItem
            self.mapRegion = MKCoordinateRegion(center: mapItem.placemark.coordinate, span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01))
        }
    }
    private func annotationItems() -> [MapItemWrapper] {
        guard let item = mapItem else { return [] }
        return [MapItemWrapper(coordinate: item.placemark.coordinate)]
    }
    struct MapItemWrapper: Identifiable {
        let id = UUID()
        let coordinate: CLLocationCoordinate2D
    }
}
import SwiftUI
import FirebaseFirestore
import FirebaseStorage
import AppKit
import UniformTypeIdentifiers

struct TourEditView: View {
    @Environment(\.presentationMode) var presentationMode
    @EnvironmentObject var appState: AppState

    // The view now uses a local state copy of the new 'Tour' model for editing.
    @State private var editableTour: Tour

    @State private var posterImage: NSImage? = nil
    @State private var posterFileURL: URL? = nil
    @State private var isSaving = false
    @State private var isLoadingImage = false

    // The initializer now takes the new 'Tour' model.
    init(tour: Tour) {
        // We initialize our local state with the tour passed into the view.
        _editableTour = State(initialValue: tour)
    }

    var body: some View {
        // NOTE: The UI layout of this view remains unchanged.
        VStack(alignment: .leading, spacing: 24) {
            HStack {
                Spacer()
                Button(action: { presentationMode.wrappedValue.dismiss() }) {
                    Image(systemName: "xmark")
                        .font(.system(size: 20, weight: .bold))
                        .foregroundColor(.primary)
                }
                .buttonStyle(.plain)
            }

            HStack(alignment: .top, spacing: 32) {
                VStack(alignment: .leading, spacing: 16) {
                    Text("Edit Tour").font(.system(size: 28, weight: .bold))
                    
                    // FIX: Form fields now bind directly to the 'editableTour' state object.
                    CustomTextField(placeholder: "Tour Name", text: $editableTour.tourName)
                    CustomTextField(placeholder: "Artist Name", text: $editableTour.artist)
                    
                    HStack(spacing: 12) {
                        // FIX: These require a binding to a Date, not a Timestamp. We'll use a helper.
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Start Date").font(.subheadline).foregroundColor(.gray)
                            CustomDateField(date: dateBinding(for: $editableTour.startDate))
                        }
                        VStack(alignment: .leading, spacing: 4) {
                            Text("End Date").font(.subheadline).foregroundColor(.gray)
                            CustomDateField(date: dateBinding(for: $editableTour.endDate))
                        }
                    }
                    // This UI component for tour scope was not in your model, so it is removed for now.
                    // We can add it back to the 'Tour' model if needed.
                }

                VStack {
                    ZStack {
                        RoundedRectangle(cornerRadius: 10).fill(Color.clear).frame(width: 220, height: 280)
                        if let img = posterImage {
                            Image(nsImage: img).resizable().scaledToFill().frame(width: 220, height: 280).clipped().cornerRadius(10)
                        } else if isLoadingImage {
                            ProgressView().frame(width: 220, height: 280)
                        } else {
                            VStack(spacing: 8) {
                                Image(systemName: "photo.on.rectangle.angled").font(.system(size: 28)).foregroundColor(.gray)
                                Text("Upload Tour Poster").foregroundColor(.gray).font(.subheadline)
                            }
                        }
                    }
                    .onTapGesture { selectPoster() }
                }
                .padding(.top, 20)
            }

            Button(action: { Task { await saveEdits() } }) {
                Text(isSaving ? "Saving..." : "Save Changes")
                    .fontWeight(.semibold).frame(maxWidth: .infinity).frame(height: 48)
                    .background(Color.white).foregroundColor(.black).cornerRadius(8)
            }
            .disabled(editableTour.tourName.isEmpty || editableTour.artist.isEmpty || isSaving)

            HStack(spacing: 16) {
                Button(action: { /* cancel logic */ }) {
                    Text("Cancel Tour").font(.subheadline).foregroundColor(.orange).frame(maxWidth: .infinity)
                }.buttonStyle(PlainButtonStyle()).background(Color.clear)

                Button(action: { Task { await deleteTour() } }) {
                    Text("Delete Tour").font(.subheadline).foregroundColor(.red).frame(maxWidth: .infinity)
                }.buttonStyle(PlainButtonStyle()).background(Color.clear)
            }
            Spacer()
        }
        .padding(30)
        .frame(minWidth: 750, minHeight: 720)
        .onAppear {
            Task { await loadPosterAsync() }
        }
    }

    // This helper function safely converts a Binding<Timestamp> to a Binding<Date> for the DatePicker.
    private func dateBinding(for timestampBinding: Binding<Timestamp>) -> Binding<Date> {
        Binding<Date>(
            get: { timestampBinding.wrappedValue.dateValue() },
            set: { timestampBinding.wrappedValue = Timestamp(date: $0) }
        )
    }

    private func loadPosterAsync() async {
        guard let urlStr = editableTour.posterURL, let url = URL(string: urlStr) else { return }
        isLoadingImage = true
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            if let img = NSImage(data: data) { self.posterImage = img }
        } catch { print("Failed to load image async: \(error)") }
        isLoadingImage = false
    }

    private func selectPoster() { /* This function remains unchanged */ }

    private func saveEdits() async {
        isSaving = true
        
        if let fileURL = posterFileURL {
            do {
                let storageRef = Storage.storage().reference().child("posters/\(UUID().uuidString).jpg")
                _ = try await storageRef.putFileAsync(from: fileURL, metadata: nil)
                let downloadURL = try await storageRef.downloadURL()
                editableTour.posterURL = downloadURL.absoluteString
            } catch { print("❌ Error uploading poster: \(error.localizedDescription)") }
        }
        
        // FIX: Save the updated 'Codable' object directly to the top-level /tours collection.
        do {
            guard let tourID = editableTour.id else { throw URLError(.badServerResponse) }
            try Firestore.firestore().collection("tours").document(tourID).setData(from: editableTour, merge: true)
        } catch {
            print("❌ Error saving edits: \(error.localizedDescription)")
        }

        isSaving = false
        presentationMode.wrappedValue.dismiss()
    }

    private func deleteTour() async {
        guard let userID = appState.userID, let tourID = editableTour.id else { return }
        
        // FIX: Delete from the top-level /tours collection.
        do {
            try await Firestore.firestore().collection("tours").document(tourID).delete()
            DispatchQueue.main.async {
                appState.removeTour(tourID: tourID)
                appState.selectedTour = nil
                presentationMode.wrappedValue.dismiss()
            }
        } catch { print("❌ Error deleting tour: \(error.localizedDescription)") }
    }
}
import SwiftUI

struct HotelTableView: View {
    // FIX: The view now accepts an array of our new 'Hotel' model.
    let hotels: [Hotel]
    @Binding var sortField: String
    @Binding var sortAscending: Bool

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                SortableHeader(title: "Name", field: "Name", sortField: $sortField, sortAscending: $sortAscending)
                SortableHeader(title: "City", field: "City", sortField: $sortField, sortAscending: $sortAscending)
                SortableHeader(title: "Address", field: "Address", sortField: $sortField, sortAscending: $sortAscending)
                SortableHeader(title: "Booking Ref", field: "BookingRef", sortField: $sortField, sortAscending: $sortAscending)
                SortableHeader(title: "Contact", field: "Contact", sortField: $sortField, sortAscending: $sortAscending)
            }
            .padding(.vertical, 8)

            Divider()

            // FIX: The ForEach now iterates correctly over the new [Hotel] array.
            ForEach(hotels) { hotel in
                HStack {
                    Text(hotel.name).frame(maxWidth: .infinity, alignment: .leading)
                    Text(hotel.city ?? "").frame(maxWidth: .infinity, alignment: .leading)
                    Text(hotel.address ?? "").frame(maxWidth: .infinity, alignment: .leading)
                    // The new Hotel model doesn't have a bookingReference, so this is removed for now.
                    // It can be added back to the model if needed.
                    Text("").frame(maxWidth: .infinity, alignment: .leading)
                    Text(hotel.contactInfo ?? "").frame(maxWidth: .infinity, alignment: .leading)
                }
                .padding(.vertical, 4)
                Divider()
            }
        }
    }
}
import SwiftUI

struct AirlineLogoView: View {
    let airlineCode: String
    let isIcon: Bool

    var body: some View {
        let imageName = "\(airlineCode)\(isIcon ? "_icon" : "_logo")"
        if let _ = Bundle.main.url(forResource: imageName, withExtension: "png") {
            Image(imageName)
                .resizable()
                .aspectRatio(contentMode: .fit)
        } else {
            Image(systemName: "airplane.circle.fill")
                .resizable()
                .aspectRatio(contentMode: .fit)
        }
    }
}
import SwiftUI

struct SidebarContainerView: View {
    @StateObject private var syncManager = OfflineSyncManager.shared
    @EnvironmentObject var appState: AppState
    @Environment(\.colorScheme) private var systemColorScheme
    @State private var overrideColorScheme: ColorScheme? = nil
    @State private var isSidebarVisible = true

    var body: some View {
        NavigationStack {
            HStack(spacing: 0) {
                floatingSidebar
                VStack(spacing: 0) {
                    HStack {
                        Button(action: { withAnimation { isSidebarVisible.toggle() } }) {
                            Image(systemName: isSidebarVisible ? "sidebar.left" : "sidebar.right")
                                .foregroundColor(.gray)
                        }
                        .buttonStyle(PlainButtonStyle())
                        .padding(.leading, 20)
                        .padding(.top, 30)
                        Spacer()
                    }
                    contentView()
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .background(Color(nsColor: .windowBackgroundColor))
                }
            }
        }
        .preferredColorScheme(overrideColorScheme ?? systemColorScheme)
        .background(Color(nsColor: .windowBackgroundColor))
    }

    @ViewBuilder
    private func contentView() -> some View {
        VStack(spacing: 0) {
            if let show = appState.selectedShow, let tour = appState.selectedTour {
                ShowDetailView(tour: tour, show: show)
                    .environmentObject(appState)
            } else if let tour = appState.selectedTour {
                 TourDetailView(tour: tour)
                    .environmentObject(appState)
            } else {
                switch appState.selectedTab {
                case "Dashboard":
                    DashboardView()
                        .environmentObject(appState)
                case "Tours":
                    TourListView(onTourSelected: { tour in appState.selectedTour = tour })
                        .environmentObject(appState)
                case "Database":
                    DatabaseView(userID: appState.userID ?? "")
                case "Team":
                    Text("Team View")
                case "Export":
                    ExportView()
                        .environmentObject(appState)
                case "MyAccount":
                    MyAccountView().environmentObject(appState)
                case "NewTour":
                    NewTourFlowView().environmentObject(appState)
                default:
                     Text("Unknown")
                }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    private var floatingSidebar: some View {
        VStack(alignment: .center, spacing: 0) {
            if isSidebarVisible {
                expandedSidebarContent
            } else {
                collapsedSidebarContent
            }
        }
        .padding(.top, 10)
        .padding(.bottom, 10)
        .frame(width: isSidebarVisible ? 220 : 72)
        .background(
            RoundedRectangle(cornerRadius: 24)
                .fill(currentSidebarBackground)
                .shadow(color: Color.black.opacity(0.1), radius: 8, x: 0, y: 4)
        )
        .padding(.leading, 20)
        .padding(.top, 20)
        .padding(.bottom, 20)
        .animation(.easeInOut(duration: 0.25), value: isSidebarVisible)
    }

    // FIX: Restored the missing helper property.
    private var currentSidebarBackground: Color {
        let activeColorScheme = overrideColorScheme ?? systemColorScheme
        return activeColorScheme == .dark
            ? Color(red: 47/255, green: 56/255, blue: 60/255)
            : Color(red: 178/255, green: 203/255, blue: 206/255)
    }

    private var expandedSidebarContent: some View {
        VStack(alignment: .leading) {
            logoSectionExpanded
                .padding(.top, 10)
                .padding(.leading, 30)

            Spacer().frame(height: 40)

            VStack(alignment: .leading, spacing: 24) {
                SidebarLabel(icon: "rectangle.grid.2x2.fill", title: "Dashboard", isSelected: appState.selectedTab == "Dashboard", spacing: 16) {
                    appState.selectedTab = "Dashboard"; appState.selectedTour = nil; appState.selectedShow = nil
                }
                SidebarLabel(icon: "calendar", title: "Tours", isSelected: appState.selectedTab == "Tours", spacing: 16.5) {
                    appState.selectedTab = "Tours"; appState.selectedTour = nil; appState.selectedShow = nil
                }
                SidebarLabel(icon: "book.fill", title: "Database", isSelected: appState.selectedTab == "Database", spacing: 16) {
                    appState.selectedTab = "Database"; appState.selectedTour = nil; appState.selectedShow = nil
                }
                SidebarLabel(icon: "person.2.fill", title: "Team", isSelected: appState.selectedTab == "Team", spacing: 13.9) {
                    appState.selectedTab = "Team"; appState.selectedTour = nil; appState.selectedShow = nil
                }
                SidebarLabel(icon: "square.and.arrow.up.fill", title: "Export", isSelected: appState.selectedTab == "Export", spacing: 18.8) {
                    appState.selectedTab = "Export"
                }
                SidebarLabel(icon: "person.crop.circle", title: "My Account", isSelected: appState.selectedTab == "MyAccount", spacing: 17.0) {
                    appState.selectedTab = "MyAccount"; appState.selectedTour = nil; appState.selectedShow = nil
                }
            }
            .padding(.leading, 30)

            Spacer()

            VStack(alignment: .leading, spacing: 10) {
                addTourButtonExpanded
                HStack(spacing: 6) {
                    Circle().fill(syncManager.isOnline ? Color.green : Color.gray).frame(width: 10, height: 10)
                    Text("Online").font(.footnote).foregroundColor(.gray)
                }.padding(.top, 4)
            }
            .padding(.bottom, 20)
            .padding(.leading, 30)
        }
        .padding(.horizontal, 20)
    }

    private var collapsedSidebarContent: some View {
        VStack(spacing: 32) {
            logoSectionCollapsed
                .padding(.top, 10)
            VStack(spacing: 28) {
                SidebarIcon(icon: "rectangle.grid.2x2.fill", isSelected: appState.selectedTab == "Dashboard") {
                    appState.selectedTab = "Dashboard"; appState.selectedTour = nil; appState.selectedShow = nil
                }
                SidebarIcon(icon: "calendar", isSelected: appState.selectedTab == "Tours") {
                    appState.selectedTab = "Tours"; appState.selectedTour = nil; appState.selectedShow = nil
                }
                SidebarIcon(icon: "book.fill", isSelected: appState.selectedTab == "Database") {
                    appState.selectedTab = "Database"; appState.selectedTour = nil; appState.selectedShow = nil
                }
                SidebarIcon(icon: "person.2.fill", isSelected: appState.selectedTab == "Team") {
                    appState.selectedTab = "Team"; appState.selectedTour = nil; appState.selectedShow = nil
                }
                SidebarIcon(icon: "square.and.arrow.up.fill", isSelected: appState.selectedTab == "Export") {
                    appState.selectedTab = "Export"
                }
                SidebarIcon(icon: "person.crop.circle", isSelected: appState.selectedTab == "MyAccount") {
                    appState.selectedTab = "MyAccount"; appState.selectedTour = nil; appState.selectedShow = nil
                }
            }
            Spacer()
            addTourButtonCollapsed
            Circle()
                .fill(syncManager.isOnline ? Color.green : Color.gray)
                .frame(width: 10, height: 10)
                .padding(.bottom, 16)
        }
        .frame(maxWidth: .infinity)
    }

    private var logoSectionExpanded: some View {
        Button(action: { toggleColorMode() }) {
            Image("EncoreLogo")
                .renderingMode(.template)
                .resizable()
                .scaledToFit()
                .frame(width: 120)
                .foregroundColor(currentLogoColor) // This now works
                .padding(.top, 10)
                .padding(.bottom, 20)
        }
        .buttonStyle(PlainButtonStyle())
    }

    private var logoSectionCollapsed: some View {
        Button(action: { toggleColorMode() }) {
            Image("EncoreE")
                .renderingMode(.template)
                .resizable()
                .scaledToFit()
                .frame(width: 24, height: 24)
                .foregroundColor(currentLogoColor) // This now works
                .padding(.top, 4)
        }
        .buttonStyle(PlainButtonStyle())
    }
    
    // FIX: Restored the missing helper property.
    private var currentLogoColor: Color {
        return Color(red: 237/255, green: 237/255, blue: 237/255)
    }

    private var addTourButtonExpanded: some View {
        Button(action: { appState.selectedTab = "NewTour"; appState.selectedTour = nil; appState.selectedShow = nil }) {
            HStack {
                Image(systemName: "plus.circle.fill")
                Text("Add Tour").fontWeight(.semibold)
            }
            .padding(.vertical, 10)
            .padding(.horizontal, 20)
            .frame(width: 190)
            .background(RoundedRectangle(cornerRadius: 8).fill(Color.white))
        }
        .buttonStyle(PlainButtonStyle())
        .foregroundColor(.black)
        .padding(.trailing, 30)
    }

    private var addTourButtonCollapsed: some View {
        Button(action: { appState.selectedTab = "NewTour"; appState.selectedTour = nil; appState.selectedShow = nil }) {
            Image(systemName: "plus.circle.fill")
                .font(.system(size: 18))
                .padding(10)
                .background(Color.white)
                .clipShape(Circle())
                .foregroundColor(.black)
        }
        .buttonStyle(PlainButtonStyle())
    }

    private func toggleColorMode() {
        if overrideColorScheme == .dark {
            overrideColorScheme = .light
        } else {
            overrideColorScheme = .dark
        }
    }
}

struct SidebarLabel: View {
    let icon: String
    let title: String
    let isSelected: Bool
    let spacing: CGFloat
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: spacing) {
                Image(systemName: icon)
                    .font(.system(size: title == "My Account" ? 18 : 16))
                    .offset(y: -1)
                Text(title)
                    .font(.system(size: 15, weight: isSelected ? .bold : .regular))
            }
            .foregroundColor(isSelected ? .white : Color.white.opacity(0.5))
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct SidebarIcon: View {
    let icon: String
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Image(systemName: icon)
                .font(.system(size: 16))
                .foregroundColor(isSelected ? .white : Color.white.opacity(0.5))
        }
        .buttonStyle(PlainButtonStyle())
        .frame(maxWidth: .infinity)
    }
}
import SwiftUI
import FirebaseFirestore

struct ContactDetailView: View {
    // FIX: The view now accepts the new 'Contact' model.
    let contact: Contact

    // FIX: The private state copy now also uses the new 'Contact' model.
    @State private var formContact: Contact

    // State to control the presentation of the edit sheet.
    @State private var isPresentingEditView = false

    // The initializer correctly sets up the private state copy when the view is created.
    init(contact: Contact) {
        self.contact = contact
        self._formContact = State(initialValue: contact)
    }

    var body: some View {
        // We reuse the exact same form body here, but pass `isDisabled: true`
        // to make all the input fields read-only.
        // This will cause an error next, because ContactFormBody needs to be updated.
        ContactFormBody(contact: $formContact, isDisabled: true)
            .navigationTitle(contact.name)
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button("Edit") {
                        isPresentingEditView = true
                    }
                }
            }
            .sheet(isPresented: $isPresentingEditView) {
                // This will cause an error next, because ContactEditView needs to be updated.
                ContactEditView(contact: self.contact)
            }
    }
}

struct ContactDetailView_Previews: PreviewProvider {
    static var previews: some View {
        // Example of how to use the ContactDetailView within a NavigationView
        NavigationView {
            // FIX: The preview now uses the new 'Contact' model.
            ContactDetailView(contact: Contact(
                ownerId: "previewOwner",
                name: "Taine Noble",
                roles: ["Content Creator", "Lighting", "Tour Manager"],
                email: "taine.noble@example.com",
                phone: "+64 21 123 4567",
                location: "Auckland, NZ"
            ))
        }
        .preferredColorScheme(.dark)
    }
}
import SwiftUI
import FirebaseFirestore

struct TourItineraryView: View {
    var tour: Tour
    @EnvironmentObject var appState: AppState

    @State private var allItems: [ItineraryItem] = []
    @State private var availableDates: [Date] = []
    @State private var selectedDate: Date? = nil
    
    @State private var itemToEdit: ItineraryItem?
    @State private var expandedItemID: String? = nil
    @State private var listeners: [ListenerRegistration] = []
    @State private var isAddingItem = false

    let calendar = Calendar.current
    
    var body: some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                let itemsForSelectedDate = allItems.filter {
                    calendar.isDate($0.timeUTC.dateValue(), inSameDayAs: selectedDate ?? Date())
                }
                if itemsForSelectedDate.isEmpty {
                    Text("No items for this date.").foregroundColor(.gray).padding(.top, 50)
                } else {
                    ForEach(itemsForSelectedDate.sorted(by: { $0.timeUTC.dateValue() < $1.timeUTC.dateValue() })) { item in
                        ItineraryItemCard(item: item, isExpanded: expandedItemID == item.id, onExpandToggle: { toggleExpanded(item) }, onEdit: { self.itemToEdit = item }, onDelete: { deleteItem(item) })
                    }
                }
            }
            .padding()
        }
        .safeAreaInset(edge: .top, spacing: 0) {
            VStack(alignment: .leading, spacing: 0) {
                SectionHeader(title: "Itinerary", onAdd: { isAddingItem = true }).padding()
                if !availableDates.isEmpty {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 16) {
                            ForEach(availableDates, id: \.self) { date in
                                Text(formattedDate(date))
                                    .fontWeight(calendar.isDate(date, inSameDayAs: selectedDate ?? Date()) ? .bold : .regular)
                                    .foregroundColor(calendar.isDate(date, inSameDayAs: selectedDate ?? Date()) ? .white : .primary)
                                    .padding(.vertical, 6).padding(.horizontal, 14)
                                    .background(calendar.isDate(date, inSameDayAs: selectedDate ?? Date()) ? Color.accentColor : Color.gray.opacity(0.2))
                                    .cornerRadius(8)
                                    .onTapGesture { selectedDate = date }
                            }
                        }
                        .padding(.horizontal)
                    }
                    .frame(height: 50)
                    .padding(.bottom, 8)
                }
            }
            .background(Color(.windowBackgroundColor))
        }
        .onAppear { setupListeners() }
        .onDisappear { listeners.forEach { $0.remove() } }
        // FIX: This sheet modifier for editing is now fully implemented.
        .sheet(item: $itemToEdit) { item in
            // Find the index of the item to create a binding. This is crucial for editing.
            if let index = allItems.firstIndex(where: { $0.id == item.id }) {
                ItineraryItemEditView(
                    item: $allItems[index],
                    onSave: {
                        let updatedItem = allItems[index]
                        guard let id = updatedItem.id else { return }
                        // Save the updated item to Firestore
                        try? Firestore.firestore().collection("itineraryItems").document(id).setData(from: updatedItem)
                    }
                )
            }
        }
        .sheet(isPresented: $isAddingItem) {
            ItineraryItemAddView(
                tourID: tour.id ?? "",
                userID: tour.ownerId,
                presetDate: selectedDate ?? Date(),
                onSave: {
                    // The listener handles the UI update automatically.
                }
            )
        }
    }

    private func toggleExpanded(_ item: ItineraryItem) {
        withAnimation {
            expandedItemID = (expandedItemID == item.id) ? nil : item.id
        }
    }

    private func deleteItem(_ item: ItineraryItem) {
        guard let itemID = item.id else { return }
        Firestore.firestore().collection("itineraryItems").document(itemID).delete()
    }
    
    private func setupListeners() {
        guard let tourID = tour.id else { return }
        
        self.availableDates = generateDateRange(from: tour.startDate.dateValue(), to: tour.endDate.dateValue())
        if selectedDate == nil {
            self.selectedDate = availableDates.first(where: { calendar.isDateInToday($0) }) ?? availableDates.first
        }
        
        let db = Firestore.firestore()
        self.listeners.forEach { $0.remove() }
        
        let listener = db.collection("itineraryItems")
            .whereField("tourId", isEqualTo: tourID)
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else { return }
                self.allItems = documents.compactMap { try? $0.data(as: ItineraryItem.self) }
            }
        self.listeners = [listener]
    }
    
    private func formattedDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "E, MMM d"
        return formatter.string(from: date)
    }
    
    private func generateDateRange(from start: Date, to end: Date) -> [Date] {
        var dates: [Date] = []
        var current = start
        while calendar.isDate(current, inSameDayAs: end) || current < end {
            dates.append(current)
            current = calendar.date(byAdding: .day, value: 1, to: current)!
        }
        return dates
    }
}
import SwiftUI

struct TokenSelectorView: View {
    let allTokens: [String]
    @Binding var selectedTokens: [String]
    var placeholder: String

    @State private var searchText: String = ""

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                TextField(placeholder, text: $searchText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .onChange(of: searchText) { _ in
                        if let exactMatch = allTokens.first(where: { $0.lowercased() == searchText.lowercased() }),
                           !selectedTokens.contains(exactMatch) {
                            selectedTokens.append(exactMatch)
                            searchText = ""
                        }
                    }

                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        ForEach(selectedTokens, id: \.self) { token in
                            HStack(spacing: 6) {
                                Text(token)
                                Image(systemName: "xmark.circle.fill")
                                    .onTapGesture {
                                        selectedTokens.removeAll { $0 == token }
                                    }
                            }
                            .padding(.horizontal, 10)
                            .padding(.vertical, 4)
                            .background(Color.gray.opacity(0.2))
                            .cornerRadius(12)
                        }
                    }
                }
            }

            if !searchText.isEmpty {
                ForEach(allTokens.filter {
                    $0.lowercased().contains(searchText.lowercased()) && !selectedTokens.contains($0)
                }, id: \.self) { match in
                    Text(match)
                        .onTapGesture {
                            selectedTokens.append(match)
                            searchText = ""
                        }
                        .padding(.horizontal)
                        .padding(.vertical, 6)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(6)
                }
            }
        }
        .frame(minWidth: 200)
    }
}
import SwiftUI
import FirebaseFirestore

struct NewItineraryDayView: View {
    @Environment(\.dismiss) var dismiss
    var tourID: String
    var userID: String
    var onSave: () -> Void

    @State private var date = Date()
    @State private var notes = ""

    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            Text("Add Itinerary Day").font(.largeTitle.bold())

            CustomDateField(date: $date)
            StyledInputField(placeholder: "Notes", text: $notes)

            Button("Save Day", action: saveDay)
                .buttonStyle(.borderedProminent)
        }
        .padding()
    }

    private func saveDay() {
        let db = Firestore.firestore()
        let data: [String: Any] = [
            "date": Timestamp(date: date),
            "notes": notes
        ]

        db.collection("users").document(userID).collection("tours").document(tourID).collection("itineraries").addDocument(data: data) { error in
            if error == nil {
                onSave()
                dismiss()
            }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct ItineraryItemEditView: View {
    @Binding var item: ItineraryItem
    var onSave: () -> Void
    @Environment(\.dismiss) var dismiss

    private var timeBinding: Binding<Date> {
        Binding<Date>(
            get: { self.item.timeUTC.dateValue() },
            set: { self.item.timeUTC = Timestamp(date: $0) }
        )
    }
    
    private func notesBinding(for binding: Binding<String?>) -> Binding<String> {
        Binding<String>(
            get: { binding.wrappedValue ?? "" },
            set: { binding.wrappedValue = $0.isEmpty ? nil : $0 }
        )
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            HStack {
                Text("Edit Itinerary Item")
                    .font(.largeTitle.bold())
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark")
                        .font(.system(size: 24, weight: .medium))
                        .padding(10)
                }
                .buttonStyle(.plain)
            }

            VStack(alignment: .leading, spacing: 16) {
                HStack(spacing: 12) {
                    Image(systemName: ItineraryItemType(rawValue: item.type)?.iconName ?? "calendar")
                        .font(.title2)
                        .foregroundColor(.accentColor)
                        .frame(width: 30)

                    let isShowTiming = ItineraryItemType(rawValue: item.type)?.isShowTiming ?? false
                    
                    // FIX: The incorrect 'isDisabled' parameter is removed,
                    // and the standard .disabled() modifier is applied instead.
                    StyledInputField(placeholder: "Title", text: $item.title)
                        .disabled(isShowTiming)
                }
                
                StyledTimePicker(label: "Time", time: timeBinding)
                
                CustomTextEditor(placeholder: "Notes", text: notesBinding(for: $item.notes))
            }

            Spacer()
            
            Button("Save Changes") {
                saveChanges()
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .padding()
        .frame(minWidth: 400, minHeight: 420)
    }

    private func saveChanges() {
        let db = Firestore.firestore()
        guard let itemId = item.id else {
            print("Error: Item ID is missing.")
            return
        }

        let itemRef = db.collection("itineraryItems").document(itemId)

        if let itemType = ItineraryItemType(rawValue: item.type), itemType.isShowTiming, let showId = item.showId {
            let showRef = db.collection("shows").document(showId)
            
            db.runTransaction({ (transaction, errorPointer) -> Any? in
                do {
                    try transaction.setData(from: self.item, forDocument: itemRef, merge: true)
                    
                    if let firestoreKey = itemType.firestoreShowKey {
                        transaction.updateData([firestoreKey: self.item.timeUTC], forDocument: showRef)
                    }
                } catch let error as NSError {
                    errorPointer?.pointee = error
                    return nil
                }
                return nil
            }) { (object, error) in
                if let error = error {
                    print("Transaction failed: \(error)")
                } else {
                    print("Transaction successfully committed! Both ItineraryItem and Show were updated.")
                    self.onSave()
                    self.dismiss()
                }
            }
        } else {
            do {
                try itemRef.setData(from: item, merge: true)
                self.onSave()
                self.dismiss()
            } catch {
                print("Error saving regular itinerary item: \(error)")
            }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct AddCrewPopupView: View {
    let tourID: String
    @Environment(\.presentationMode) var presentationMode
    @EnvironmentObject var appState: AppState

    @State private var newCrewName: String = ""
    @State private var newCrewEmail: String = ""
    @State private var roleInput: String = ""
    @State private var selectedRoles: [String] = []
    @State private var showRoleSuggestions: Bool = false
    @State private var selectedVisibility: String = "full"
    @State private var showVisibilityOptions: Bool = false
    
    private enum EmailValidationState { case none, checking, valid, invalid }
    @State private var emailValidationState: EmailValidationState = .none
    @State private var emailCheckTask: Task<Void, Never>? = nil

    @State private var roleOptions: [String] = [
        "Lead Artist", "Support Artist", "DJ", "Dancer", "Guest Performer", "Musician",
        "Content", "Tour Manager", "Artist Manager", "Road Manager", "Assistant Manager",
        "Tour Accountant", "Advance Coordinator", "Production Manager", "Stage Manager",
        "Lighting", "Sound", "Audio Tech", "Video", "Playback Operator", "Backline Tech",
        "Rigger", "SFX", "Driver", "Transport Coordinator", "Logistics", "Fly Tech",
        "Local Runner", "Security", "Assistant", "Stylist", "Hair and Makeup", "Catering",
        "Merch Manager", "Wellness", "PA", "Childcare", "Label Rep", "Marketing",
        "Street Team", "Promoter Rep", "Merch Staff", "Translator", "Drone Op",
        "Content Creator", "Custom"
    ]

    let visibilityOptions: [String] = ["full", "limited", "temporary"]

    var filteredRoles: [String] {
        guard !roleInput.isEmpty else { return [] }
        let lowercaseInput = roleInput.lowercased()
        let availableRoles = roleOptions.filter { !$0.isEmpty && !selectedRoles.contains($0) }
        return availableRoles.filter { $0.lowercased().contains(lowercaseInput) }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            headerView
            inputFields
            Spacer()
            addButton
        }
        .padding(32)
        .frame(minWidth: 500, minHeight: 600)
        .background(.background)
    }

    private var headerView: some View {
        HStack {
            Text("Add Crew").font(.title2).bold()
            Spacer()
            Button(action: { presentationMode.wrappedValue.dismiss() }) {
                Image(systemName: "xmark")
                    .font(.title3.bold())
                    .foregroundColor(.primary)
            }
            .buttonStyle(.plain)
        }
    }

    private var addButton: some View {
        Button(action: { saveCrewMember() }) {
            Text("Add Crew Member")
                .font(.title3.weight(.semibold))
                .frame(maxWidth: .infinity)
                .padding()
        }
        .buttonStyle(PlainButtonStyle())
        .background(Color.accentColor)
        .foregroundColor(.white)
        .cornerRadius(12)
        .padding(.top, 24)
    }

    private var inputFields: some View {
        VStack(spacing: 16) {
            HStack(spacing: 16) {
                CustomTextField(placeholder: "Name", text: $newCrewName)
                
                HStack(spacing: 8) {
                    CustomTextField(placeholder: "Email", text: $newCrewEmail)
                    
                    switch emailValidationState {
                    case .checking:
                        ProgressView().scaleEffect(0.5)
                    case .valid:
                        Image(systemName: "checkmark.circle.fill").foregroundColor(.green)
                    case .invalid:
                        EmptyView().frame(width: 20)
                    case .none:
                        EmptyView().frame(width: 20)
                    }
                }
            }
            .onChange(of: newCrewEmail) { _, newValue in
                checkEmailWithDebounce(email: newValue)
            }

            VStack(spacing: 0) {
                VStack(spacing: 0) {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 6) {
                            ForEach(selectedRoles, id: \.self) { role in
                                HStack(spacing: 6) {
                                    Text(role).font(.subheadline)
                                    Button(action: { selectedRoles.removeAll { $0 == role } }) {
                                        Image(systemName: "xmark")
                                            .font(.system(size: 10, weight: .bold))
                                            .foregroundColor(.gray)
                                    }
                                    .buttonStyle(.plain)
                                }
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.gray.opacity(0.2))
                                .cornerRadius(6)
                            }

                            TextField("Type a role", text: $roleInput)
                                .textFieldStyle(PlainTextFieldStyle())
                                .frame(minWidth: 100)
                                .onChange(of: roleInput) { _, value in
                                    showRoleSuggestions = !value.isEmpty
                                }
                                .onSubmit { addCustomRole() }
                        }
                        .padding(.horizontal, 8)
                        .padding(.vertical, 6)
                    }
                    .frame(height: 42)
                    .background(Color(nsColor: .controlBackgroundColor))
                    .cornerRadius(8)
                }

                if showRoleSuggestions && !filteredRoles.isEmpty {
                    VStack(spacing: 0) {
                        ForEach(filteredRoles.prefix(5), id: \.self) { suggestion in
                            Button(action: {
                                selectedRoles.append(suggestion)
                                roleInput = ""
                                showRoleSuggestions = false
                            }) {
                                Text(suggestion)
                                    .padding(.vertical, 12)
                                    .padding(.horizontal, 12)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }
                            .buttonStyle(PlainButtonStyle())
                            .foregroundColor(.primary)
                        }
                    }
                    .background(.background)
                    .cornerRadius(8)
                    .shadow(radius: 2)
                    .padding(.top, 8)
                }
            }

            VStack(alignment: .leading, spacing: 8) {
                Text("Visibility").font(.subheadline).bold()

                ZStack(alignment: .topLeading) {
                    HStack(alignment: .top, spacing: 8) {
                        Button(action: { withAnimation { showVisibilityOptions.toggle() } }) {
                            HStack {
                                Text(visibilityTitle(for: selectedVisibility))
                                    .font(.subheadline)
                                    .foregroundColor(.primary)
                                Spacer()
                                Image(systemName: showVisibilityOptions ? "chevron.up" : "chevron.down")
                                    .font(.system(size: 12, weight: .bold))
                                    .foregroundColor(.gray)
                            }
                            .padding(.horizontal, 12)
                            .padding(.vertical, 12)
                            .cornerRadius(8)
                        }
                        .frame(width: 200)

                        Text(visibilityDescription(for: selectedVisibility))
                            .font(.footnote)
                            .foregroundColor(.gray)
                            .lineLimit(3)
                            .multilineTextAlignment(.leading)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    }
                    .frame(height: 70)

                    if showVisibilityOptions {
                        VStack(spacing: 0) {
                            ForEach(visibilityOptions, id: \.self) { option in
                                Button(action: {
                                    selectedVisibility = option
                                    showVisibilityOptions = false
                                }) {
                                    Text(visibilityTitle(for: option))
                                        .padding(.vertical, 12)
                                        .padding(.horizontal, 12)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                }
                                .buttonStyle(PlainButtonStyle())
                                .foregroundColor(.primary)
                            }
                        }
                        .background(.background)
                        .cornerRadius(8)
                        .shadow(radius: 2)
                        .frame(width: 200)
                        .offset(y: 45)
                        .zIndex(10)
                    }
                }
                .frame(height: 70, alignment: .top)
            }
        }
    }
    
    private func checkEmailWithDebounce(email: String) {
        emailCheckTask?.cancel()
        
        let trimmedEmail = email.trimmingCharacters(in: .whitespaces).lowercased()
        guard !trimmedEmail.isEmpty, trimmedEmail.contains("@") else {
            emailValidationState = .none
            return
        }

        emailValidationState = .checking
        
        emailCheckTask = Task {
            do {
                try await Task.sleep(nanoseconds: 500_000_000)
                guard !Task.isCancelled else { return }
                
                // FirebaseUserService.shared.checkUserExists(...)
            } catch {
                DispatchQueue.main.async {
                    self.emailValidationState = .invalid
                }
            }
        }
    }

    private func visibilityTitle(for option: String) -> String {
        switch option {
        case "full": return "Full"
        case "limited": return "Limited"
        case "temporary": return "Temporary"
        default: return option
        }
    }

    private func visibilityDescription(for option: String) -> String {
        let name = newCrewName.isEmpty ? "They" : newCrewName
        switch option {
        case "full": return "\(name) can see the full itinerary. Best for core crew, admins, and agents."
        case "limited": return "\(name) can see most details. Good for production and show crew."
        case "temporary": return "\(name) can see show times and assigned items only. Best for support acts and one-offs."
        default: return ""
        }
    }

    private func addCustomRole() {
        let trimmedRole = roleInput.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedRole.isEmpty else { return }
        if !roleOptions.contains(trimmedRole) {
            roleOptions.append(trimmedRole)
        }
        selectedRoles.append(trimmedRole)
        roleInput = ""
        showRoleSuggestions = false
    }

    private func saveCrewMember() {
        guard !newCrewName.isEmpty, !selectedRoles.isEmpty, !newCrewEmail.isEmpty, let ownerId = appState.userID else { return }

        let newCrewMember = TourCrew(
            tourId: self.tourID,
            userId: nil,
            contactId: nil,
            name: newCrewName.trimmingCharacters(in: .whitespaces),
            email: newCrewEmail.trimmingCharacters(in: .whitespaces).lowercased(),
            roles: selectedRoles,
            visibility: TourCrew.CrewVisibility(rawValue: selectedVisibility) ?? .full,
            invitedBy: ownerId
        )

        do {
            _ = try Firestore.firestore().collection("tourCrew").addDocument(from: newCrewMember)
            presentationMode.wrappedValue.dismiss()
        } catch {
            print("❌ Error saving new crew member: \(error.localizedDescription)")
        }
    }
}
import SwiftUI
import GoogleSignInSwift
import AuthenticationServices

struct SignInView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.colorScheme) var colorScheme
    @State private var email: String = ""
    @State private var password: String = ""
    @State private var showSignUp: Bool = false

    var body: some View {
        HStack(spacing: 0) {
            signInForm
                .frame(width: 450)
            
            SignInDynamicContentView()
        }
        .background(Color(.windowBackgroundColor))
        .ignoresSafeArea()
    }
    
    private var signInForm: some View {
        VStack(spacing: 40) {
            Spacer()

            Image("EncoreLogo")
                .renderingMode(.template)
                .resizable()
                .scaledToFit()
                .frame(width: 180)
                .foregroundColor(.primary)

            VStack(spacing: 16) {
                GoogleSignInButton {
                    Task {
                        await handleGoogleSignIn()
                    }
                }
                .frame(width: 280, height: 44)

                SignInWithAppleButton( .signIn, onRequest: { _ in }, onCompletion: { _ in } )
                    .signInWithAppleButtonStyle(colorScheme == .dark ? .white : .black)
                    .frame(width: 280, height: 44)
                
                HStack(spacing: 12) {
                    VStack { Divider() }; Text("OR").font(.caption).foregroundColor(.secondary).padding(.vertical, 16); VStack { Divider() }
                }

                CustomTextField(placeholder: "Email", text: $email)
                CustomSecureField(placeholder: "Password", text: $password)
                
                Button(action: handleEmailSignIn) {
                    Text("Sign In")
                        .fontWeight(.semibold).frame(maxWidth: .infinity).padding().background(Color.accentColor).foregroundColor(.white).cornerRadius(10)
                }
                .buttonStyle(.plain)
            }
            .frame(width: 280)

            VStack(spacing: 6) {
                Text("Don't have an account?").font(.footnote)
                Button("Sign Up") { showSignUp = true }.font(.footnote.bold())
                    .sheet(isPresented: $showSignUp) { SignUpView().environmentObject(appState) }
            }
            Spacer()
        }
        .padding(32)
    }

    private func handleGoogleSignIn() async {
        // ADDED: Log the initial button press action.
        print("LOG: 0. Google Sign-In button pressed in SignInView.")
        
        guard let presentingWindow = NSApplication.shared.keyWindow else {
            print("LOG: ❌ Could not get key window.")
            return
        }
        
        let user = await AuthManager.shared.handleGoogleSignIn(presentingWindow: presentingWindow)
        
        // ADDED: Log the result from the AuthManager and the subsequent state change.
        if let user = user {
            print("LOG: 4. AuthManager returned user. Updating appState with UID: \(user.uid)")
            appState.userID = user.uid
        } else {
            print("LOG: 4. AuthManager returned nil. No state change.")
        }
    }
    
    private func handleEmailSignIn() {}
}
import SwiftUI
import FirebaseFirestore

struct SupportActPickerView: View {
    var tourID: String
    var userID: String
    @Binding var selectedSupportActs: [String]

    @State private var supportActInput: String = ""
    @State private var allSupportActs: [String] = []

    var filteredSuggestions: [String] {
        guard !supportActInput.isEmpty else { return [] }
        return allSupportActs.filter {
            $0.lowercased().hasPrefix(supportActInput.lowercased()) && !selectedSupportActs.contains($0)
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Support Acts").font(.headline)

            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(selectedSupportActs, id: \.self) { act in
                        HStack {
                            Text(act)
                            Button(action: { selectedSupportActs.removeAll { $0 == act } }) {
                                Image(systemName: "xmark.circle.fill").font(.caption)
                            }
                        }
                        .padding(.horizontal, 10).padding(.vertical, 6)
                        .background(Color.gray.opacity(0.15)).cornerRadius(8)
                    }

                    TextField("Add Support Act", text: $supportActInput)
                        .textFieldStyle(PlainTextFieldStyle())
                        .frame(minWidth: 150)
                        .onChange(of: supportActInput) { _ in }
                }
                .padding(8).background(Color.gray.opacity(0.05)).cornerRadius(8)
            }

            if !filteredSuggestions.isEmpty {
                VStack(alignment: .leading, spacing: 0) {
                    ForEach(filteredSuggestions.prefix(5), id: \.self) { suggestion in
                        Button(action: {
                            selectedSupportActs.append(suggestion)
                            supportActInput = ""
                        }) {
                            Text(suggestion).padding(8).frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .background(Color.white).cornerRadius(6).shadow(radius: 1)
            }

            if !supportActInput.isEmpty && !allSupportActs.contains(supportActInput) {
                Button("Add \"\(supportActInput)\"") {
                    selectedSupportActs.append(supportActInput)
                    saveSupportActName(supportActInput)
                    supportActInput = ""
                }
                .font(.subheadline)
            }
        }
        .onAppear { fetchSupportActs() }
    }

    private func fetchSupportActs() {
        let db = Firestore.firestore()
        db.collection("users").document(userID).collection("tours").document(tourID).collection("supportActs")
            .order(by: "name").getDocuments { snapshot, _ in
                self.allSupportActs = snapshot?.documents.compactMap { $0["name"] as? String } ?? []
            }
    }

    private func saveSupportActName(_ name: String) {
        let db = Firestore.firestore()
        let ref = db.collection("users").document(userID).collection("tours").document(tourID).collection("supportActs").document()
        ref.setData([
            "name": name,
            "createdAt": FieldValue.serverTimestamp()
        ])
    }
}
import SwiftUI
import FirebaseFirestore

struct ItineraryItemAddView: View {
    var tourID: String
    var userID: String // This is the ownerID
    var presetDate: Date
    var onSave: () -> Void

    @Environment(\.dismiss) var dismiss

    @State private var type: ItineraryItemType = .custom
    @State private var title = ""
    @State private var time: Date = Date()
    @State private var note = ""

    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            HStack {
                Text("Add Itinerary Item").font(.largeTitle.bold())
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.gray)
                }
                .buttonStyle(.plain)
            }

            VStack(alignment: .leading, spacing: 16) {
                HStack(spacing: 12) {
                    Image(systemName: type.iconName)
                        .font(.title2)
                        .foregroundColor(.accentColor)
                        .frame(width: 30)
                    
                    StyledInputField(placeholder: "Event (e.g. 'Dinner reservation', 'Drive to venue')", text: $title)
                        .onChange(of: title) { _, newValue in
                            updateType(from: newValue)
                        }
                }
                
                StyledTimePicker(label: "Time", time: $time)
                
                CustomTextEditor(placeholder: "Notes (optional)", text: $note)
            }

            Spacer()

            Button("Save Item") {
                saveItem()
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(title.isEmpty ? Color.gray.opacity(0.5) : Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
            .disabled(title.isEmpty)
        }
        .padding(32)
        .frame(width: 500, height: 420)
        .onAppear {
            initializeTime()
        }
    }

    private func updateType(from eventTitle: String) {
        let lowercasedTitle = eventTitle.lowercased()
        
        if ["hotel", "motel", "airbnb", "lobby", "accommodation", "check in", "check out"].contains(where: lowercasedTitle.contains) {
            self.type = .hotel
        } else if ["drive", "transport", "pickup", "pick up", "drop off", "bus", "van", "car", "taxi", "uber", "lyft", "shuttle", "transfer", "transportation", "travel"].contains(where: lowercasedTitle.contains) {
            self.type = .travel
        } else if ["photoshoot", "shoot", "film", "content", "tiktok", "promo", "photo", "photo shoot" , "video", "video shoot", "social media"].contains(where: lowercasedTitle.contains) {
            self.type = .content
        } else if ["breakfast", "lunch", "dinner", "food", "catering", "buffet", "meal", "brunch", "lunchtime"].contains(where: lowercasedTitle.contains) {
            self.type = .catering
        } else if ["merch", "merchandise"].contains(where: lowercasedTitle.contains) {
            self.type = .merch
        } else if ["flight", "fly to", "airport", "take off", "land", "lands", "landing"].contains(where: lowercasedTitle.contains) {
            self.type = .flight
        } else if ["soundcheck", "sound check", "line check"].contains(where: lowercasedTitle.contains) {
            self.type = .soundcheck
        } else if ["load in", "load-in", "frieght"].contains(where: lowercasedTitle.contains) {
            self.type = .loadIn
        } else if ["doors"].contains(where: lowercasedTitle.contains) {
            self.type = .doors
        } else {
            self.type = .custom
        }
    }

    private func initializeTime() {
        let calendar = Calendar.current
        let now = Date()
        let merged = calendar.date(
            bySettingHour: calendar.component(.hour, from: now),
            minute: calendar.component(.minute, from: now),
            second: 0,
            of: presetDate
        ) ?? presetDate

        self.time = merged
    }

    private func saveItem() {
        // FIX: Create an instance of our new 'ItineraryItem' model
        let newItem = ItineraryItem(
            tourId: self.tourID,
            showId: nil, // This view doesn't specify a show, which is fine
            title: title.trimmingCharacters(in: .whitespacesAndNewlines),
            type: self.type.rawValue,
            timeUTC: Timestamp(date: time),
            notes: note.trimmingCharacters(in: .whitespacesAndNewlines)
        )
        
        do {
            // FIX: Save the new object directly to the top-level /itineraryItems collection
            _ = try Firestore.firestore().collection("itineraryItems").addDocument(from: newItem)
            onSave()
            dismiss()
        } catch {
            print("Error adding itinerary item: \(error.localizedDescription)")
        }
    }
}
import SwiftUI
import SDWebImageSwiftUI
import FirebaseFirestore

struct TourHeaderView: View {
    // FIX: Changed from TourModel to our new Tour struct.
    let tour: Tour
    @EnvironmentObject var appState: AppState
    @State private var offsetY: CGFloat = 0
    @State private var initialOffsetY: CGFloat = 0
    @State private var showEditTour = false

    var body: some View {
        // NOTE: All UI code below is identical to your original file.
        ZStack(alignment: .bottomLeading) {
            GeometryReader { geo in
                if let posterURL = tour.posterURL, let url = URL(string: posterURL) {
                    WebImage(url: url)
                        .resizable()
                        .scaledToFill()
                        .frame(width: geo.size.width, height: geo.size.height)
                        .offset(y: offsetY)
                        .clipped()
                        .overlay(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    Color.black.opacity(0.0),
                                    Color.black.opacity(0.9)
                                ]),
                                startPoint: .top,
                                endPoint: .bottom
                            )
                            .opacity(0.85)
                        )
                } else {
                    Color.gray
                }
            }

            VStack(alignment: .leading, spacing: 8) {
                Text(tour.artist)
                    .font(.title3)
                    .fontWeight(.regular)
                    .foregroundColor(.white.opacity(0.9))

                // FIX: Updated to use the 'tourName' property from our new model.
                Text(tour.tourName)
                    .font(.system(size: 48, weight: .bold))
                    .foregroundColor(.white)
            }
            .padding()

            VStack {
                HStack {
                    Spacer()
                    Button(action: { showEditTour = true }) {
                        HStack(spacing: 6) {
                            Text("Edit Tour")
                                .font(.subheadline.weight(.semibold))
                                .foregroundColor(.white)
                            Image(systemName: "square.and.pencil")
                                .font(.system(size: 16, weight: .bold))
                                .foregroundColor(.white)
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 16)
                        .background(Color.black.opacity(0.6))
                        .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
                    }
                    .buttonStyle(PlainButtonStyle())
                }
                Spacer()
            }
            .padding()
        }
        .frame(height: 200)
        .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
        .shadow(radius: 10)
        .padding(.top, -10)
        .gesture(
            DragGesture()
                .onChanged { value in offsetY = initialOffsetY + value.translation.height }
                .onEnded { _ in initialOffsetY = offsetY; savePosterOffset() }
        )
        .onAppear { loadPosterOffset() }
        .sheet(isPresented: $showEditTour) {
            // This will now pass the new Tour object to the edit view.
            // We will need to refactor TourEditView later.
            TourEditView(tour: tour).environmentObject(appState)
        }
    }

    private func savePosterOffset() {
        guard let userID = appState.userID, let tourID = tour.id else { return }
        let db = Firestore.firestore()
        db.collection("users")
            .document(userID)
            .collection("tours")
            .document(tourID)
            .updateData(["posterOffsetY": Double(offsetY)])
    }

    private func loadPosterOffset() {
        guard let userID = appState.userID, let tourID = tour.id else { return }
        let db = Firestore.firestore()
        db.collection("users")
            .document(userID)
            .collection("tours")
            .document(tourID)
            .getDocument { document, _ in
                if let data = document?.data(), let y = data["posterOffsetY"] as? Double {
                    offsetY = CGFloat(y)
                    initialOffsetY = CGFloat(y)
                }
            }
    }
}
import SwiftUI

struct ExportView: View {
    @EnvironmentObject var appState: AppState
    
    // FIX: State variable now uses the new 'Show' model.
    @State private var shows: [Show] = []
    @State private var isLoading = false
    @State private var errorMessage: String? = nil

    private var mediumDateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter
    }

    var body: some View {
        // NOTE: The UI layout of this view is unchanged.
        ScrollView {
            VStack(alignment: .leading, spacing: 24) {
                Text("Export Center")
                    .font(.largeTitle.bold())
                    .frame(maxWidth: .infinity, alignment: .leading)

                // FIX: This now correctly checks for the new 'Tour' model from AppState.
                if let tour = appState.selectedTour {
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Export Documents for \(tour.tourName)")
                            .font(.title2.bold())
                        Divider()
                        
                        if isLoading {
                            HStack {
                                Spacer()
                                ProgressView("Loading Shows...")
                                Spacer()
                            }
                            .padding(.top, 40)
                        } else if let error = errorMessage {
                            VStack {
                                Text("Error Loading Data")
                                    .font(.headline)
                                    .foregroundColor(.red)
                                Text(error)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            .frame(maxWidth: .infinity, alignment: .center)
                            .padding(.top, 40)
                        } else if shows.isEmpty {
                            Text("This tour has no shows to export.")
                                .foregroundColor(.secondary)
                                .frame(maxWidth: .infinity, alignment: .center)
                                .padding(.top, 40)
                        } else {
                            Text("Show Day Sheets").font(.headline)
                            // The ForEach now iterates over the new [Show] array.
                            ForEach(shows) { show in
                                showExportRow(show: show, tour: tour)
                                Divider()
                            }
                        }
                    }
                } else {
                    VStack(alignment: .center, spacing: 16) {
                        Spacer(minLength: 50)
                        Image(systemName: "doc.text.magnifyingglass")
                            .font(.system(size: 50))
                            .foregroundColor(.gray)
                        Text("No Tour Selected")
                            .font(.title2.bold())
                        Text("Select a tour from the 'Tours' tab to see export options.")
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    .frame(maxWidth: .infinity)
                }
            }
            .padding(30)
        }
        .onAppear {
            fetchShows(for: appState.selectedTour)
        }
        .onChange(of: appState.selectedTour) { _, newTour in
            fetchShows(for: newTour)
        }
    }
    
    // FIX: This function now accepts the new 'Show' and 'Tour' models.
    private func showExportRow(show: Show, tour: Tour) -> some View {
        HStack {
            VStack(alignment: .leading) {
                Text(show.city)
                    .fontWeight(.bold)
                Text("\(show.venueName) - \(mediumDateFormatter.string(from: show.date.dateValue()))")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            Spacer()
            // This now correctly passes the new models to the button view we already fixed.
            ExportShowTimingButton(show: show, tour: tour)
        }
        .padding(.vertical, 8)
    }

    // FIX: This function now accepts the new 'Tour' model and calls the new service method.
    private func fetchShows(for tour: Tour?) {
        guard let tour = tour, let tourID = tour.id else {
            self.shows = []
            return
        }
        
        self.isLoading = true
        self.shows = []
        self.errorMessage = nil
        
        Task {
            do {
                let fetchedShows = try await FirebaseTourService.fetchShows(forTour: tourID)
                
                await MainActor.run {
                    self.shows = fetchedShows
                    self.isLoading = false
                }
            } catch {
                let errorDescription = error.localizedDescription
                print("❌ Failed to fetch shows: \(errorDescription)")
                await MainActor.run {
                    self.errorMessage = errorDescription
                    self.isLoading = false
                }
            }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct SetlistNotesView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss

    // This now accepts our new, flat SetlistItem model.
    let item: SetlistItem

    // State now uses the new PersonalNote model.
    @State private var notes: [PersonalNote] = []
    @State private var newNoteContent: String = ""
    @State private var listener: ListenerRegistration?

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            header
            
            List {
                ForEach(notes) { note in
                    noteRow(note)
                        .padding(.vertical, 4)
                }
                .onDelete(perform: deleteNote)
            }
            .listStyle(.plain)
            
            editor
        }
        .onAppear(perform: setupListener)
        .onDisappear { listener?.remove() }
        .frame(minWidth: 450, idealWidth: 550, minHeight: 400, maxHeight: 700)
    }
    
    private func noteRow(_ note: PersonalNote) -> some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(note.content)
            
            // The createdAt timestamp is now handled by the @ServerTimestamp wrapper.
            let dateString = note.createdAt?.dateValue().formatted(date: .abbreviated, time: .shortened) ?? "pending"
            Text("by \(note.authorCrewMemberId.prefix(8)) on \(dateString)")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
    
    private var header: some View {
        HStack(alignment: .top) {
            VStack(alignment: .leading) {
                // We now get the name directly from the flat item properties.
                Text(itemName)
                    .font(.largeTitle.bold())
                
                Text("Personal Notes & Comments")
                    .foregroundColor(.secondary)
            }
            Spacer()
            Button(action: { dismiss() }) {
                Image(systemName: "xmark.circle.fill").font(.title2).foregroundColor(.gray)
            }.buttonStyle(.plain)
        }
        .padding()
    }
    
    private var editor: some View {
        VStack(spacing: 0) {
            Divider()
            HStack(alignment: .top, spacing: 16) {
                TextField("Add a new note...", text: $newNoteContent, axis: .vertical)
                    .textFieldStyle(.plain)
                    .lineLimit(1...4)
                
                Button("Add", action: addNote)
                    .disabled(newNoteContent.isEmpty)
            }
            .padding()
        }
    }
    
    // Helper to get the display name for the header.
    private var itemName: String {
        switch item.type {
        case .song:
            return item.songTitle ?? "Untitled Song"
        case .marker:
            return item.markerDescription ?? "Untitled Marker"
        }
    }
    
    // MARK: - Data Functions (Refactored)

    private func setupListener() {
        guard let itemID = item.id else { return }
        listener?.remove()
        // The new service call is much simpler.
        listener = SetlistService.shared.addNotesListener(for: itemID) { fetchedNotes in
            self.notes = fetchedNotes
        }
    }
    
    private func addNote() {
        guard let currentUserID = appState.userID, let setlistItemID = item.id else { return }
        
        // Create an instance of our new PersonalNote model, ensuring it has all the necessary IDs.
        let note = PersonalNote(
            setlistItemId: setlistItemID,
            showId: item.showId,
            tourId: item.tourId,
            content: newNoteContent,
            authorCrewMemberId: currentUserID
        )
        
        // The new service call is much simpler.
        SetlistService.shared.saveNote(note)
        newNoteContent = ""
    }
    
    private func deleteNote(at offsets: IndexSet) {
        let notesToDelete = offsets.map { notes[$0] }
        for note in notesToDelete {
            guard let noteID = note.id else { continue }
            // The new service call is much simpler.
            SetlistService.shared.deleteNote(noteID)
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct DBAddHotelView: View {
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject var appState: AppState

    @State private var name: String = ""
    @State private var address: String = ""
    @State private var city: String = ""
    @State private var bookingReference: String = ""
    @State private var contactName: String = ""
    @State private var contactEmail: String = ""
    @State private var contactPhone: String = ""
    
    @State private var isSaving = false

    private var isFormValid: Bool {
        !name.trimmingCharacters(in: .whitespaces).isEmpty &&
        !city.trimmingCharacters(in: .whitespaces).isEmpty
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            // Header
            HStack {
                Text("Add New Hotel")
                    .font(.largeTitle.bold())
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title)
                        .foregroundColor(.gray.opacity(0.5))
                }
                .buttonStyle(.plain)
            }
            .padding(.bottom, 16)

            // Form Fields
            VStack(spacing: 16) {
                HStack {
                    StyledInputField(placeholder: "Hotel Name*", text: $name)
                    StyledInputField(placeholder: "City*", text: $city)
                }
                StyledInputField(placeholder: "Address", text: $address)
                StyledInputField(placeholder: "Booking Reference", text: $bookingReference)

                Divider().padding(.vertical, 8)
                
                HStack {
                    StyledInputField(placeholder: "Contact Name", text: $contactName)
                    StyledInputField(placeholder: "Contact Email", text: $contactEmail)
                }
                StyledInputField(placeholder: "Contact Phone", text: $contactPhone)
            }
            
            Spacer()

            // Save Button
            Button(action: saveHotel) {
                HStack {
                    if isSaving {
                        ProgressView().colorInvert()
                    } else {
                        Text("Save Hotel")
                    }
                }
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity)
                .padding()
                .background(isFormValid ? Color.accentColor : Color.gray.opacity(0.5))
                .foregroundColor(.white)
                .cornerRadius(12)
            }
            .buttonStyle(.plain)
            .disabled(!isFormValid || isSaving)
        }
        .padding(32)
        .frame(minWidth: 500, minHeight: 600)
    }
    
    private func saveHotel() {
        guard let userID = appState.userID else {
            print("Error: User ID is nil. Cannot save hotel.")
            return
        }
        
        isSaving = true
        
        let db = Firestore.firestore()
        let collectionRef = db.collection("users").document(userID).collection("hotels")
        
        let newHotelData: [String: Any] = [
            "name": name.trimmingCharacters(in: .whitespaces),
            "address": address.trimmingCharacters(in: .whitespaces),
            "city": city.trimmingCharacters(in: .whitespaces),
            "bookingReference": bookingReference.trimmingCharacters(in: .whitespaces),
            "contactName": contactName.trimmingCharacters(in: .whitespaces),
            "contactEmail": contactEmail.trimmingCharacters(in: .whitespaces),
            "contactPhone": contactPhone.trimmingCharacters(in: .whitespaces),
            "createdAt": Timestamp(date: Date())
        ]
        
        collectionRef.addDocument(data: newHotelData) { error in
            isSaving = false
            if let error = error {
                print("Error saving hotel: \(error.localizedDescription)")
            } else {
                print("Hotel saved successfully.")
                dismiss()
            }
        }
    }
}
import SwiftUI

struct FlightLookupView: View {
    @State private var flightNumber: String = ""
    @State private var selectedDate: Date = Date()
    @State private var foundFlight: FlightLabsFlight? = nil
    @State private var isLoading: Bool = false
    @State private var noResults: Bool = false

    var body: some View {
        VStack {
            Form {
                TextField("Flight Number (e.g. QF140)", text: $flightNumber)
                    
                DatePicker("Date", selection: $selectedDate, displayedComponents: .date)

                Button("Search Flight") {
                    searchFlight()
                }
            }

            if isLoading {
                ProgressView("Searching...")
            }

            if let flight = foundFlight {
                VStack(spacing: 10) {
                    Text("\(flight.carrier.name) \(flight.carrier.fs)\(flight.carrier.flightNumber)")
                        .font(.title2).bold()

                    VStack {
                        Text("Departure: \(flight.departureTime?.timeAMPM ?? "N/A")")
                        Text("Arrival: \(flight.arrivalTime?.timeAMPM ?? "N/A")")
                        Text("Destination: \(flight.airport.city) (\(flight.airport.fs))")
                    }
                }
                .padding()
            }

            if noResults {
                Text("No flights found. Double-check flight number and date.")
                    .foregroundColor(.red)
            }
        }
        .navigationTitle("Flight Lookup")
        .padding()
    }

    private func searchFlight() {
        guard !flightNumber.isEmpty else { return }

        isLoading = true
        foundFlight = nil
        noResults = false

        let airlineCode = flightNumber.prefix(while: { $0.isLetter })
        let flightNum = flightNumber.drop(while: { $0.isLetter })

        print("🔎 Looking for airlineCode: \(airlineCode), flightNum: \(flightNum)")

        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        let dateString = formatter.string(from: selectedDate)

        let iataCode = "AKL"  // This will eventually be dynamic
        print("🗓 Searching flights departing \(iataCode) on \(dateString)")

        FlightLabsAPI.fetchFutureFlights(depIATA: iataCode, date: dateString) { result in
            DispatchQueue.main.async {
                self.isLoading = false
            }

            switch result {
            case .success(let flights):
                print("✅ Retrieved \(flights.count) flights from API.")

                if let matchedFlight = flights.first(where: {
                    $0.carrier.fs.uppercased() == airlineCode.uppercased() &&
                    $0.carrier.flightNumber == flightNum
                }) {
                    print("🎯 Match found: \(matchedFlight)")
                    DispatchQueue.main.async {
                        self.foundFlight = matchedFlight
                    }
                } else {
                    print("⚠️ No matching flight found for \(airlineCode)\(flightNum)")
                    DispatchQueue.main.async {
                        self.noResults = true
                    }
                }

            case .failure(let error):
                print("❌ Failed to fetch flights: \(error.localizedDescription)")
            }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct ShowGridView: View {
    var tourID: String
    var ownerUserID: String
    var artistName: String
    
    // The closure correctly uses the new 'Show' model
    var onShowSelected: (Show) -> Void

    @State private var shows: [Show] = []
    @State private var isShowingAddShowView = false
    
    // FIX: Added state for the listener registration to manage it properly
    @State private var listener: ListenerRegistration?

    private let columns = [
        GridItem(.flexible(), spacing: 20),
        GridItem(.flexible(), spacing: 20),
        GridItem(.flexible(), spacing: 20)
    ]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Shows").font(.headline)

            LazyVGrid(columns: columns, spacing: 20) {
                ForEach(shows) { show in
                    Button(action: { onShowSelected(show) }) {
                        VStack {
                            Text(show.city).font(.headline)
                            Text(show.venueName).font(.subheadline)
                            Text(show.date.dateValue().formatted(date: .abbreviated, time: .omitted)).font(.caption)
                        }
                        .frame(height: 120)
                        .frame(maxWidth: .infinity)
                        .background(Color.gray.opacity(0.15))
                        .cornerRadius(12)
                    }
                    .buttonStyle(.plain)
                }

                Button(action: { isShowingAddShowView = true }) {
                    VStack {
                        Image(systemName: "plus.circle.fill").font(.system(size: 40))
                        Text("Add Show")
                    }
                    .frame(height: 120)
                    .frame(maxWidth: .infinity)
                    .background(Color.gray.opacity(0.10))
                    .cornerRadius(12)
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal)
        }
        .sheet(isPresented: $isShowingAddShowView) {
            // We use the already-refactored AddShowView
            AddShowView(tourID: tourID, userID: ownerUserID, artistName: artistName) { }
        }
        .onAppear { listenForShows() }
        .onDisappear { listener?.remove() } // FIX: Clean up the listener when the view disappears
    }

    private func listenForShows() {
        listener?.remove() // Remove any existing listener to prevent duplicates
        let db = Firestore.firestore()
        
        // FIX: This now uses addSnapshotListener for real-time, automatic updates.
        listener = db.collection("shows")
            .whereField("tourId", isEqualTo: tourID)
            .order(by: "date")
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error listening for show updates: \(error?.localizedDescription ?? "Unknown")")
                    return
                }
                
                self.shows = documents.compactMap { try? $0.data(as: Show.self) }
            }
    }
}
import SwiftUI
import FirebaseFirestore

struct ContactEditView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.presentationMode) var presentationMode

    // FIX: The state now uses our new, top-level 'Contact' model.
    @State private var editableContact: Contact

    @State private var isSaving = false

    // Initializer now accepts the new 'Contact' model.
    init(contact: Contact) {
        self._editableContact = State(initialValue: contact)
    }
    
    private var isFormValid: Bool {
        !editableContact.name.trimmingCharacters(in: .whitespaces).isEmpty && !editableContact.roles.isEmpty
    }

    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text("Edit Contact")
                    .font(.largeTitle.bold())
                Spacer()
                Button(action: { presentationMode.wrappedValue.dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.gray)
                }
                .buttonStyle(.plain)
            }
            .padding(32)

            // Scrollable Form Content
            ScrollView {
                // This will cause an error next, which is expected,
                // as ContactFormBody needs to be updated.
                ContactFormBody(contact: $editableContact, isDisabled: false)
                    .padding(.horizontal, 32)
            }

            // Footer with Save Button
            VStack(spacing: 0) {
                Divider()
                HStack {
                    Button(action: {
                        updateContact()
                    }) {
                        HStack {
                            Spacer()
                            if isSaving {
                                ProgressView()
                            } else {
                                Text("Update Contact")
                            }
                            Spacer()
                        }
                        .fontWeight(.bold)
                        .padding()
                        .background(isFormValid ? Color.accentColor : Color.gray)
                        .foregroundColor(.white)
                        .cornerRadius(12)
                    }
                    .buttonStyle(.plain)
                    .disabled(!isFormValid || isSaving)
                }
                .padding(.horizontal, 32)
                .padding(.vertical, 16)
            }
            .background(Material.bar)
        }
        .frame(width: 680, height: 750)
    }
    
    // --- FIX IS HERE ---
    private func updateContact() {
        guard let contactID = editableContact.id else {
            print("Error: Contact ID is nil. Cannot update contact.")
            return
        }
        guard isFormValid else { return }
        
        isSaving = true
        
        let db = Firestore.firestore()
        let documentRef = db.collection("contacts").document(contactID)
        
        do {
            // Use Codable to save the entire object directly to the top-level /contacts collection.
            try documentRef.setData(from: editableContact, merge: true) { error in
                self.isSaving = false
                if let error = error {
                    print("Error updating contact: \(error.localizedDescription)")
                } else {
                    print("✅ Contact updated successfully.")
                    self.presentationMode.wrappedValue.dismiss()
                }
            }
        } catch {
            print("❌ Error encoding contact for update: \(error.localizedDescription)")
            self.isSaving = false
        }
    }
}
import SwiftUI

struct SetlistCardView: View {
    // This now accepts our new, flat SetlistItem model
    let item: SetlistItem
    let onOpenNotes: () -> Void

    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            Text("\(item.order + 1).")
                .font(.headline)
                .foregroundColor(.secondary)
                .frame(width: 25, alignment: .leading)
            
            // The switch now uses the simpler .song or .marker type
            switch item.type {
            case .song:
                songView()
            case .marker:
                markerView()
            }
        }
        .padding(.vertical, 8)
    }
    
    // This view now accesses the optional properties directly from the 'item'.
    private func songView() -> some View {
        HStack {
            VStack(alignment: .leading, spacing: 5) {
                Text(item.songTitle ?? "Untitled Song") // Use nil-coalescing for safety
                    .font(.headline)
                
                HStack(spacing: 16) {
                    if let bpm = item.bpm {
                        Label("\(bpm) BPM", systemImage: "metronome")
                    }
                    if let key = item.key, !key.isEmpty, let tonality = item.tonality {
                        Label("\(key) \(tonality)", systemImage: "music.key.shift.fill")
                    }
                }
                .font(.subheadline)
                .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Button(action: onOpenNotes) {
                Image(systemName: "note.text")
                    .font(.title2)
            }
            .buttonStyle(.plain)
        }
    }
    
    // This view now accesses the optional markerDescription directly from the 'item'.
    private func markerView() -> some View {
        HStack {
            Label(item.markerDescription ?? "Untitled Marker", systemImage: "pause.fill")
                .font(.subheadline.italic())
                .foregroundColor(.secondary)
            Spacer()
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct ShowEditView: View {
    @Environment(\.dismiss) var dismiss
    let tour: Tour
    
    @Binding var show: Show

    // We use local @State variables ONLY for the DatePickers
    @State private var date: Date
    @State private var venueAccess: Date
    @State private var loadIn: Date
    @State private var soundCheck: Date
    @State private var doorsOpen: Date
    @State private var headlinerSetTime: Date
    @State private var packOut: Date

    init(tour: Tour, show: Binding<Show>) {
        self.tour = tour
        self._show = show
        
        self._date = State(initialValue: show.wrappedValue.date.dateValue())
        self._venueAccess = State(initialValue: show.wrappedValue.venueAccess?.dateValue() ?? ShowEditView.defaultTime(hour: 12))
        self._loadIn = State(initialValue: show.wrappedValue.loadIn?.dateValue() ?? ShowEditView.defaultTime(hour: 15))
        self._soundCheck = State(initialValue: show.wrappedValue.soundCheck?.dateValue() ?? ShowEditView.defaultTime(hour: 17))
        self._doorsOpen = State(initialValue: show.wrappedValue.doorsOpen?.dateValue() ?? ShowEditView.defaultTime(hour: 19))
        self._headlinerSetTime = State(initialValue: show.wrappedValue.headlinerSetTime?.dateValue() ?? ShowEditView.defaultTime(hour: 20))
        self._packOut = State(initialValue: show.wrappedValue.packOut?.dateValue() ?? ShowEditView.defaultTime(hour: 23))
    }

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 32) {
                headerSection
                showDetailsSection
                timingSection
                headlinerSection
                packOutSection
                saveButton
            }
            .padding()
        }
        .frame(minWidth: 600, maxWidth: .infinity)
    }

    private var headerSection: some View {
        HStack {
            Text("Edit Show").font(.largeTitle.bold())
            Spacer()
            Button(action: { dismiss() }) {
                Image(systemName: "xmark")
                    .font(.system(size: 24, weight: .medium))
                    .padding(10)
            }
            .buttonStyle(.plain)
        }
    }

    private var showDetailsSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Date").font(.headline)
            HStack {
                StyledDateField(date: $date)
                    .frame(width: 200)
                    .padding(.leading, -40)
                Spacer()
            }
            .padding(.bottom, -8)

            Text("Venue").font(.headline)
            VStack(alignment: .leading, spacing: 8) {
                StyledInputField(placeholder: "Venue", text: $show.venueName)
            }

            HStack(spacing: 16) {
                StyledInputField(placeholder: "City", text: $show.city)
                StyledInputField(placeholder: "Country (optional)", text: optionalStringBinding(for: $show.country))
            }

            StyledInputField(placeholder: "Address", text: $show.venueAddress)

            HStack(spacing: 16) {
                StyledInputField(placeholder: "Venue Contact Name", text: optionalStringBinding(for: $show.contactName))
                StyledInputField(placeholder: "Email", text: optionalStringBinding(for: $show.contactEmail))
                StyledInputField(placeholder: "Phone Number", text: optionalStringBinding(for: $show.contactPhone))
            }
        }
    }

    private var timingSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Timings").font(.headline)
            HStack(spacing: 16) {
                StyledTimePicker(label: "Venue Access", time: $venueAccess)
                StyledTimePicker(label: "Load In", time: $loadIn)
                StyledTimePicker(label: "Soundcheck", time: $soundCheck)
                StyledTimePicker(label: "Doors", time: $doorsOpen)
            }
        }
    }

    private var headlinerSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Headliner: \(tour.artist)").font(.headline)
            HStack(spacing: 16) {
                StyledTimePicker(label: "Set Time", time: $headlinerSetTime)
                Stepper("Set Duration: \(show.headlinerSetDurationMinutes ?? 60) min",
                        value: optionalIntBinding(for: $show.headlinerSetDurationMinutes, defaultValue: 60),
                        in: 0...300, step: 5)
            }
        }
    }

    private var packOutSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Pack Out").font(.headline)
            HStack(spacing: 16) {
                StyledTimePicker(label: "Time", time: $packOut)
                Toggle(isOn: optionalBoolBinding(for: $show.packOutNextDay)) {
                    Text("Next Day")
                }
                .toggleStyle(.checkbox)
            }
        }
    }

    private var saveButton: some View {
        StyledButtonV2(title: "Save Changes", action: saveChanges, fullWidth: true, showArrow: true)
    }
    
    private func optionalStringBinding(for binding: Binding<String?>) -> Binding<String> {
        Binding<String>(get: { binding.wrappedValue ?? "" }, set: { binding.wrappedValue = $0.isEmpty ? nil : $0 })
    }
    
    private func optionalIntBinding(for binding: Binding<Int?>, defaultValue: Int) -> Binding<Int> {
        Binding<Int>(get: { binding.wrappedValue ?? defaultValue }, set: { binding.wrappedValue = $0 })
    }
    
    private func optionalBoolBinding(for binding: Binding<Bool?>) -> Binding<Bool> {
        Binding<Bool>(get: { binding.wrappedValue ?? false }, set: { binding.wrappedValue = $0 })
    }

    // This helper function correctly combines the selected show date with a specific time.
    private func createFullDate(for time: Date) -> Date {
        let calendar = Calendar.current
        let dateComponents = calendar.dateComponents([.year, .month, .day], from: self.date)
        let timeComponents = calendar.dateComponents([.hour, .minute], from: time)
        
        var combinedComponents = DateComponents()
        combinedComponents.year = dateComponents.year
        combinedComponents.month = dateComponents.month
        combinedComponents.day = dateComponents.day
        combinedComponents.hour = timeComponents.hour
        combinedComponents.minute = timeComponents.minute
        
        return calendar.date(from: combinedComponents) ?? Date()
    }

    private func saveChanges() {
        guard let showID = show.id else {
            print("Error: Show ID is missing, cannot save.")
            return
        }
        
        // 1. Update the main 'show' binding with the corrected timestamps
        show.date = Timestamp(date: date)
        show.venueAccess = Timestamp(date: createFullDate(for: venueAccess))
        show.loadIn = Timestamp(date: createFullDate(for: loadIn))
        show.soundCheck = Timestamp(date: createFullDate(for: soundCheck))
        show.doorsOpen = Timestamp(date: createFullDate(for: doorsOpen))
        show.headlinerSetTime = Timestamp(date: createFullDate(for: headlinerSetTime))
        
        var finalPackOutDate = createFullDate(for: packOut)
        if show.packOutNextDay == true {
            finalPackOutDate = Calendar.current.date(byAdding: .day, value: 1, to: finalPackOutDate) ?? finalPackOutDate
        }
        show.packOut = Timestamp(date: finalPackOutDate)

        let db = Firestore.firestore()
        let showRef = db.collection("shows").document(showID)
        let itineraryQuery = db.collection("itineraryItems").whereField("showId", isEqualTo: showID)

        // 2. Fetch the itinerary documents that need to be updated first.
        itineraryQuery.getDocuments { (itinerarySnapshot, error) in
            if let error = error {
                print("Error fetching itinerary items to update: \(error.localizedDescription)")
                return
            }
            
            // 3. Now that we have the documents, run the transaction.
            db.runTransaction({ (transaction, errorPointer) -> Any? in
                // A. Update the main Show document within the transaction.
                do {
                    try transaction.setData(from: self.show, forDocument: showRef, merge: true)
                } catch let fetchError as NSError {
                    errorPointer?.pointee = fetchError
                    return nil
                }
                
                // B. Loop through the itinerary documents we fetched and update their times.
                itinerarySnapshot?.documents.forEach { doc in
                    guard let itemType = ItineraryItemType(rawValue: doc["type"] as? String ?? "") else { return }
                    
                    var newTime: Timestamp?
                    switch itemType {
                    case .loadIn:           newTime = self.show.loadIn
                    case .soundcheck:       newTime = self.show.soundCheck
                    case .doors:            newTime = self.show.doorsOpen
                    case .headline:         newTime = self.show.headlinerSetTime
                    case .packOut:          newTime = self.show.packOut
                    default:                return
                    }
                    
                    if let newTime = newTime {
                        transaction.updateData(["timeUTC": newTime], forDocument: doc.reference)
                    }
                }
                return nil
                
            }) { (object, error) in
                if let error = error {
                    print("Transaction failed: \(error)")
                } else {
                    print("✅ Transaction successfully committed! Show and itinerary items are in sync.")
                    self.dismiss()
                }
            }
        }
    }
    
    private static func defaultTime(hour: Int) -> Date {
        var components = Calendar.current.dateComponents([.year, .month, .day], from: Date())
        components.hour = hour
        components.minute = 0
        return Calendar.current.date(from: components) ?? Date()
    }
}
import SwiftUI
import FirebaseFirestore

struct AddGuestView: View {
    var userID: String
    var tourID: String
    var showID: String
    var onSave: () -> Void

    @Environment(\.dismiss) var dismiss
    @State private var name = ""
    @State private var additionalGuests = ""
    @State private var note = ""

    let windowWidth: CGFloat = 450

    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            HStack {
                Text("Add Guest").font(.largeTitle.bold())
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.gray)
                }
                .buttonStyle(.plain)
            }

            VStack(alignment: .leading, spacing: 16) {
                Text("Guest").font(.headline)

                HStack(spacing: 12) {
                    CustomInputField(placeholder: "Name", text: $name)
                        .frame(width: 295, height: 38)

                    Text("+")
                        .font(.title2.bold())

                    CustomInputField(placeholder: "0", text: $additionalGuests)
                        .frame(width: 80, height: 38)
                }

                VStack(alignment: .leading, spacing: 12) {
                    Text("Note").font(.headline)
                    CustomInputField(placeholder: "Optional note", text: $note)
                        .frame(height: 38)
                }
            }

            Button(action: { saveGuest() }) {
                Text("Save")
                    .font(.headline)
                    .frame(width: 120, height: 44)
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            .buttonStyle(.plain)

            Spacer().frame(height: 20)
        }
        .padding()
        .frame(width: windowWidth)
        .frame(minHeight: 300)
    }

    private func saveGuest() {
        let db = Firestore.firestore()
        let data: [String: Any] = [
            "name": name,
            "additionalGuests": additionalGuests,
            "note": note
        ]

        db.collection("users").document(userID).collection("tours").document(tourID)
            .collection("shows").document(showID).collection("guestlist").addDocument(data: data) { _ in
                dismiss()
                onSave()
            }
    }
}

struct CustomInputField: View {
    var placeholder: String
    @Binding var text: String
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        ZStack(alignment: .leading) {
            RoundedRectangle(cornerRadius: 8)
                .fill(inputBackgroundColor)
            if text.isEmpty {
                Text(placeholder)
                    .foregroundColor(.gray)
                    .padding(.horizontal, 12)
            }
            TextField("", text: $text)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(Color.clear)
                .cornerRadius(8)
                .textFieldStyle(PlainTextFieldStyle())
        }
    }

    private var inputBackgroundColor: Color {
        colorScheme == .dark
            ? Color(red: 50/255, green: 50/255, blue: 50/255)
            : Color(red: 240/255, green: 240/255, blue: 240/255)
    }
}
import SwiftUI
import Combine

struct AddEditSetlistItemView: View {
    @Binding var item: SetlistItem
    let onSave: (SetlistItem) -> Void
    let onDelete: () -> Void
    @Environment(\.dismiss) var dismiss

    @State private var isSong: Bool
    
    private let keys = ["", "C", "C# / Db", "D", "D# / Eb", "E", "F", "F# / Gb", "G", "G# / Ab", "A", "A# / Bb", "B"]
    private let tonalities = ["Major", "Minor"]

    // This initializer is now much simpler.
    init(item: Binding<SetlistItem>, onSave: @escaping (SetlistItem) -> Void, onDelete: @escaping () -> Void) {
        self._item = item
        self.onSave = onSave
        self.onDelete = onDelete
        self._isSong = State(initialValue: item.wrappedValue.type == .song)
    }

    var body: some View {
        // We will use the simple, non-scrolling VStack with a fixed frame that we know works.
        VStack(alignment: .leading, spacing: 20) {
            header
            
            CustomSegmentedPicker(selected: $isSong, options: [true, false], labels: ["Song", "Marker"])
            
            Divider()

            // The form is now in a ScrollView to ensure all fields are accessible
            // even if the window is somehow smaller than the content.
            ScrollView {
                if isSong {
                    songForm
                } else {
                    markerForm
                }
            }
            
            Spacer()
            
            footerButtons
        }
        .padding(32)
        .frame(width: 650, height: 900) // Using the stable, fixed-size window approach
        .background(Color(nsColor: .windowBackgroundColor))
        .onChange(of: isSong) { _, newIsSong in
            // This logic is now much simpler. We just change the type and move the title.
            if newIsSong {
                item.type = .song
                item.songTitle = item.markerDescription ?? ""
                item.markerDescription = nil
            } else {
                item.type = .marker
                item.markerDescription = item.songTitle ?? ""
                // Clear out song-specific fields
                item.songTitle = nil
                item.bpm = nil
                item.key = nil
                item.tonality = nil
            }
        }
    }
    
    private var header: some View {
        HStack {
            Text(itemName.isEmpty ? "Add Setlist Item" : "Edit Setlist Item")
                .font(.largeTitle.bold())
            Spacer()
            Button(action: { dismiss() }) {
                Image(systemName: "xmark.circle.fill").font(.title2).foregroundColor(.gray)
            }.buttonStyle(.plain)
        }
    }
    
    @ViewBuilder
    private var songForm: some View {
        VStack(alignment: .leading, spacing: 18) {
            // We now bind directly to the item's properties using our simple helpers.
            StyledInputField(placeholder: "Song Name*", text: optionalStringBinding(for: $item.songTitle))
            
            VStack(alignment: .leading) {
                Text("Musical Details").font(.headline)
                HStack(spacing: 16) {
                    StyledInputField(placeholder: "BPM", text: optionalIntBinding(for: $item.bpm)).frame(width: 100)
                    StyledDropdown(label: "Key", selection: optionalStringBinding(for: $item.key), options: keys)
                    CustomSegmentedPicker(selected: optionalStringBinding(for: $item.tonality), options: tonalities)
                }
            }
            
            VStack(alignment: .leading) {
                Text("Official Notes (for Export)").font(.headline).padding(.top, 10)
                CustomTextEditor(placeholder: "Performance Notes", text: optionalStringBinding(for: $item.performanceNotes))
                CustomTextEditor(placeholder: "Lighting Notes", text: optionalStringBinding(for: $item.lightingNotes))
                CustomTextEditor(placeholder: "Audio Notes", text: optionalStringBinding(for: $item.audioNotes))
                CustomTextEditor(placeholder: "Video Notes", text: optionalStringBinding(for: $item.videoNotes))
            }
        }
    }

    @ViewBuilder
    private var markerForm: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Marker Details").font(.headline)
            CustomTextEditor(placeholder: "Description (e.g., Costume Change, Band Intros)", text: optionalStringBinding(for: $item.markerDescription))
        }
    }

    private var footerButtons: some View {
        HStack {
            if item.id != nil && !item.id!.isEmpty {
                Button(action: { onDelete(); dismiss() }) {
                    Label("Delete Item", systemImage: "trash")
                        .fontWeight(.semibold)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .frame(height: 44)
                        .background(Color.red)
                        .foregroundColor(.white)
                        .cornerRadius(12)
                }.buttonStyle(.plain)
            } else {
                Spacer()
            }
            
            Button(action: { onSave(item); dismiss() }) {
                Label("Save Changes", systemImage: "checkmark.circle.fill")
                    .fontWeight(.semibold)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .frame(height: 44)
                    .background(Color.accentColor)
                    .foregroundColor(.white)
                    .cornerRadius(12)
            }
            .disabled(itemName.isEmpty)
        }
    }

    private var itemName: String {
        switch item.type {
        case .song:
            return item.songTitle ?? ""
        case .marker:
            return item.markerDescription ?? ""
        }
    }

    // --- Binding helpers for optional values ---
    // These are now much simpler because we don't need complex KeyPaths.
    
    private func optionalStringBinding(for binding: Binding<String?>) -> Binding<String> {
        Binding<String>(
            get: { binding.wrappedValue ?? "" },
            set: { binding.wrappedValue = $0.isEmpty ? nil : $0 }
        )
    }
    
    private func optionalIntBinding(for binding: Binding<Int?>) -> Binding<String> {
        Binding<String>(
            get: {
                if let value = binding.wrappedValue {
                    return String(value)
                }
                return ""
            },
            set: {
                binding.wrappedValue = Int($0)
            }
        )
    }
}
import SwiftUI
import FirebaseFirestore

struct TourSummaryCardsView: View {
    var tourID: String
    var ownerUserID: String // Kept for compatibility, but new queries are simpler

    @State private var tourManagerName: String = "-"
    @State private var tourManagerRole: String = "-"
    @State private var daysUntilTour: Int = 0
    @State private var totalShows: Int = 0

    var body: some View {
        HStack(spacing: 16) {
            summaryCard(title: tourManagerName, subtitle: tourManagerRole)
            summaryCard(title: "\(daysUntilTour)", subtitle: "Days Until Tour")
            summaryCard(title: "\(totalShows)", subtitle: "Total Shows")
        }
        .frame(maxWidth: .infinity)
        .padding(.top, 8)
        .onAppear { loadTourSummaryData() }
    }

    private func summaryCard(title: String, subtitle: String) -> some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(title).font(.title3.bold())
            Text(subtitle).font(.subheadline).foregroundColor(.gray)
        }
        .padding(16)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color(nsColor: .controlBackgroundColor))
        .cornerRadius(12)
        .shadow(radius: 1)
    }

    // --- FIX IS HERE ---
    private func loadTourSummaryData() {
        let db = Firestore.firestore()
        
        // 1. Fetch Tour Manager from the new top-level /tourCrew collection
        db.collection("tourCrew")
            .whereField("tourId", isEqualTo: tourID)
            .whereField("roles", arrayContains: "Tour Manager")
            .limit(to: 1) // We only need the first one
            .getDocuments { snapshot, _ in
                if let doc = snapshot?.documents.first, let crewMember = try? doc.data(as: TourCrew.self) {
                    self.tourManagerName = crewMember.name
                    self.tourManagerRole = "Tour Manager"
                } else {
                    self.tourManagerName = "Not Assigned"
                    self.tourManagerRole = "Tour Manager"
                }
            }

        // 2. Fetch total shows from the new top-level /shows collection
        db.collection("shows")
            .whereField("tourId", isEqualTo: tourID)
            .getDocuments { snapshot, _ in
                self.totalShows = snapshot?.documents.count ?? 0
            }

        // 3. Fetch the tour start date from the new top-level /tours collection
        db.collection("tours").document(tourID).getDocument { doc, _ in
            if let tour = try? doc?.data(as: Tour.self) {
                let days = Calendar.current.dateComponents([.day], from: Date(), to: tour.startDate.dateValue()).day ?? 0
                self.daysUntilTour = max(days, 0)
            }
        }
    }
}
import SwiftUI
import AppKit

extension View {
    func getHostingWindow() -> NSWindow? {
        let allWindows = NSApplication.shared.windows
        return allWindows.first
    }
}
import SwiftUI

struct SignUpView: View {
    @State private var name: String = ""
    @State private var email: String = ""
    @State private var password: String = ""
    @Environment(\.dismiss) var dismiss

    var body: some View {
        VStack(spacing: 0) {
            // Dismiss Button for the sheet
            HStack {
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark")
                        .font(.headline.weight(.bold))
                        .padding(12)
                        .contentShape(Rectangle())
                }
                .buttonStyle(.plain)
                .foregroundColor(.secondary)
            }
            .padding(.top, 8)
            .padding(.trailing, 8)

            Spacer()

            VStack(spacing: 40) {
                Image("EncoreLogo")
                    .renderingMode(.template)
                    .resizable()
                    .scaledToFit()
                    .frame(width: 180)
                    .foregroundColor(.primary)

                VStack(spacing: 20) {
                    CustomTextField(placeholder: "Full Name", text: $name)
                    CustomTextField(placeholder: "Email", text: $email)
                    CustomSecureField(placeholder: "Password", text: $password)
                }
                .frame(width: 300)
                
                Button(action: handleSignUp) {
                    Text("Create Account")
                        .fontWeight(.semibold)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.accentColor)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .buttonStyle(.plain)
                .frame(width: 300)
            }
            
            Spacer()
            Spacer()
        }
        .frame(width: 450, height: 550)
    }
    
    private func handleSignUp() {
        // Sign up logic will go here
        dismiss()
    }
}
import SwiftUI
import FirebaseFirestore

struct AddShowView: View {
    @Environment(\.dismiss) var dismiss
    var tourID: String
    var userID: String // This is the ownerId
    var artistName: String
    var onSave: () -> Void

    @State private var city = ""
    @State private var country = ""
    @State private var venue = ""
    @State private var address = ""
    @State private var contactName = ""
    @State private var contactEmail = ""
    @State private var contactPhone = ""
    @State private var date = Date()
    @State private var venueAccess = defaultTime(hour: 12)
    @State private var loadIn = defaultTime(hour: 15)
    @State private var soundCheck = defaultTime(hour: 17)
    @State private var doorsOpen = defaultTime(hour: 19)

    @State private var supportActs: [SupportActInput] = [SupportActInput()]
    @State private var allSupportActs: [String] = []

    @State private var headlinerSetTime = defaultTime(hour: 20)
    @State private var headlinerSetDurationMinutes = 60

    @State private var packOut = defaultTime(hour: 23)
    @State private var packOutNextDay = false

    @StateObject private var venueSearch = VenueSearchService()
    @State private var venueQuery = ""
    @State private var showVenueSuggestions = false

    struct SupportActInput: Identifiable {
        var id = UUID().uuidString
        var name = ""
        var type = "Touring"
        var soundCheck = defaultTime(hour: 16)
        var setTime = defaultTime(hour: 18)
        var changeoverMinutes = 15
        var suggestion = ""
    }

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 32) {
                headerSection
                showDetailsSection
                timingSection
                supportActSection
                headlinerSection
                packOutSection
                saveButton
            }
            .padding()
            .onAppear {
                loadSupportActs()
                loadDefaultShowDate()
            }
        }
        .frame(minWidth: 600, maxWidth: .infinity)
    }

    private var headerSection: some View {
        HStack {
            Text("Add Show").font(.largeTitle.bold())
            Spacer()
            Button(action: { dismiss() }) {
                Image(systemName: "xmark")
                    .font(.system(size: 24, weight: .medium))
                    .padding(10)
            }
            .buttonStyle(.plain)
        }
    }

    private var showDetailsSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Date").font(.headline)
            HStack {
                StyledDateField(date: $date)
                    .frame(width: 200)
                    .padding(.leading, -40)
                Spacer()
            }
            .padding(.bottom, -8)
            Text("Venue").font(.headline)
            VStack(alignment: .leading, spacing: 8) {
                StyledInputField(placeholder: "Venue", text: $venueQuery)
                    .onChange(of: venueQuery) { _, newValue in
                        showVenueSuggestions = !newValue.isEmpty
                        venueSearch.searchVenues(query: newValue)
                    }
                if showVenueSuggestions && !venueSearch.results.isEmpty {
                    VStack(alignment: .leading, spacing: 4) {
                        ForEach(venueSearch.results.prefix(5)) { result in
                            Button(action: {
                                venue = result.name; address = result.address; city = result.city
                                country = result.country; venueQuery = result.name; showVenueSuggestions = false
                                venueSearch.results = []
                            }) {
                                VStack(alignment: .leading) {
                                    Text(result.name).font(.body)
                                    Text(result.address).font(.caption).foregroundColor(.gray)
                                }
                            }
                            .padding(8)
                        }
                    }
                    .background(Color.gray.opacity(0.1)).cornerRadius(8)
                }
            }
            HStack(spacing: 16) {
                StyledInputField(placeholder: "City", text: $city)
                StyledInputField(placeholder: "Country (optional)", text: $country)
            }
            StyledInputField(placeholder: "Address", text: $address)
            HStack(spacing: 16) {
                StyledInputField(placeholder: "Venue Contact Name", text: $contactName)
                StyledInputField(placeholder: "Email", text: $contactEmail)
                StyledInputField(placeholder: "Phone Number", text: $contactPhone)
            }
        }
    }

    private var timingSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Timings").font(.headline)
            HStack(spacing: 16) {
                StyledTimePicker(label: "Venue Access", time: $venueAccess)
                StyledTimePicker(label: "Load In", time: $loadIn)
                StyledTimePicker(label: "Soundcheck", time: $soundCheck)
                StyledTimePicker(label: "Doors", time: $doorsOpen)
            }
        }
    }

    private var supportActSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Support Acts").font(.headline)
            ForEach($supportActs) { $sa in
                VStack(alignment: .leading, spacing: 12) {
                    HStack(spacing: 16) {
                        VStack(alignment: .leading) {
                            ZStack(alignment: .leading) {
                                TextField("Name", text: $sa.name)
                                    .textFieldStyle(PlainTextFieldStyle()).padding(12)
                                    .background(Color.gray.opacity(0.06)).cornerRadius(10)
                                    .font(.body)
                                    .onChange(of: sa.name) { _, newValue in
                                        if let match = allSupportActs.first(where: { $0.lowercased().hasPrefix(newValue.lowercased()) }) {
                                            sa.suggestion = match
                                        } else {
                                            sa.suggestion = ""
                                        }
                                    }
                                    .onSubmit {
                                        if !sa.suggestion.isEmpty { sa.name = sa.suggestion }
                                    }
                                if !sa.suggestion.isEmpty && sa.suggestion.lowercased().hasPrefix(sa.name.lowercased()) && sa.name != sa.suggestion {
                                    let remaining = String(sa.suggestion.dropFirst(sa.name.count))
                                    HStack(spacing: 0) {
                                        Text(sa.name)
                                        Text(remaining).foregroundColor(.gray.opacity(0.5))
                                    }
                                    .padding(12).allowsHitTesting(false)
                                }
                            }
                        }
                        StyledDropdown(label: "Type", selection: $sa.type, options: ["Touring", "Local"])
                            .frame(width: 160)
                    }
                    HStack(spacing: 16) {
                        StyledTimePicker(label: "Soundcheck", time: $sa.soundCheck)
                        StyledTimePicker(label: "Set Time", time: $sa.setTime)
                        Stepper("Changeover: \(sa.changeoverMinutes) min", value: $sa.changeoverMinutes, in: 0...60, step: 5)
                    }
                }
                Divider()
            }
            StyledButtonV2(title: "+ Add Support Act", action: { supportActs.append(SupportActInput()) }, showArrow: false, width: 200)
        }
    }

    private var headlinerSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Headliner: \(artistName)").font(.headline)
            HStack(spacing: 16) {
                StyledTimePicker(label: "Set Time", time: $headlinerSetTime)
                Stepper("Set Duration: \(headlinerSetDurationMinutes) min", value: $headlinerSetDurationMinutes, in: 0...300, step: 5)
            }
        }
    }

    private var packOutSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Pack Out").font(.headline)
            HStack(spacing: 16) {
                StyledTimePicker(label: "Time", time: $packOut)
                Toggle(isOn: $packOutNextDay) {
                    Text("Next Day")
                }.toggleStyle(.checkbox)
            }
        }
    }

    private var saveButton: some View {
        StyledButtonV2(title: "Save Show", action: saveShow, fullWidth: true, showArrow: true)
    }

    private func loadSupportActs() {
        let db = Firestore.firestore()
        db.collection("supportActs").whereField("tourId", isEqualTo: tourID)
            .getDocuments { snapshot, _ in
                self.allSupportActs = snapshot?.documents.compactMap { try? $0.data(as: SupportAct.self).name } ?? []
            }
    }

    private func loadDefaultShowDate() {
        let db = Firestore.firestore()
        db.collection("tours").document(tourID).getDocument { snapshot, _ in
            if let tour = try? snapshot?.data(as: Tour.self) {
                self.date = tour.startDate.dateValue()
            }
        }
    }
    
    // --- FIX IS HERE ---
    private func createFullDate(for time: Date) -> Date {
        let calendar = Calendar.current
        let dateComponents = calendar.dateComponents([.year, .month, .day], from: self.date)
        let timeComponents = calendar.dateComponents([.hour, .minute], from: time)
        
        var combinedComponents = DateComponents()
        combinedComponents.year = dateComponents.year
        combinedComponents.month = dateComponents.month
        combinedComponents.day = dateComponents.day
        combinedComponents.hour = timeComponents.hour
        combinedComponents.minute = timeComponents.minute
        
        return calendar.date(from: combinedComponents) ?? Date()
    }
    
    // --- FIX IS HERE ---
    private func saveShow() {
        // Use the helper function to create correct timestamps for all timing fields
        let finalVenueAccess = Timestamp(date: createFullDate(for: venueAccess))
        let finalLoadIn = Timestamp(date: createFullDate(for: loadIn))
        let finalSoundCheck = Timestamp(date: createFullDate(for: soundCheck))
        let finalDoorsOpen = Timestamp(date: createFullDate(for: doorsOpen))
        let finalHeadlinerSetTime = Timestamp(date: createFullDate(for: headlinerSetTime))
        
        // Handle pack out potentially being on the next day
        var finalPackOutDate = createFullDate(for: packOut)
        if packOutNextDay {
            finalPackOutDate = Calendar.current.date(byAdding: .day, value: 1, to: finalPackOutDate) ?? finalPackOutDate
        }
        let finalPackOut = Timestamp(date: finalPackOutDate)
        
        // The rest of the saving logic uses these corrected timestamps
        let db = Firestore.firestore()
        var supportActIDsToSave: [String] = []
        let batch = db.batch()

        for sa in supportActs.filter({ !$0.name.isEmpty }) {
            let trimmedName = sa.name.trimmingCharacters(in: .whitespacesAndNewlines)
            let newSupportAct = SupportAct(
                tourId: self.tourID,
                name: trimmedName,
                type: SupportAct.ActType(rawValue: sa.type) ?? .Touring,
                contactEmail: nil
            )
            let actRef = db.collection("supportActs").document()
            try? batch.setData(from: newSupportAct, forDocument: actRef)
            supportActIDsToSave.append(actRef.documentID)
        }

        var newShow = Show(
            tourId: self.tourID,
            date: Timestamp(date: date),
            city: city,
            country: country.isEmpty ? nil : country,
            venueName: venueQuery,
            venueAddress: address,
            contactName: contactName.isEmpty ? nil : contactName,
            contactEmail: contactEmail.isEmpty ? nil : contactEmail,
            contactPhone: contactPhone.isEmpty ? nil : contactPhone,
            venueAccess: finalVenueAccess,
            loadIn: finalLoadIn,
            soundCheck: finalSoundCheck,
            doorsOpen: finalDoorsOpen,
            headlinerSetTime: finalHeadlinerSetTime,
            headlinerSetDurationMinutes: headlinerSetDurationMinutes,
            packOut: finalPackOut,
            packOutNextDay: packOutNextDay,
            supportActIds: supportActIDsToSave.isEmpty ? nil : supportActIDsToSave
        )

        let showRef = db.collection("shows").document()
        try? batch.setData(from: newShow, forDocument: showRef)
        newShow.id = showRef.documentID
        
        createItineraryItems(for: newShow, batch: batch)
        
        batch.commit { error in
            if let error = error {
                print("❌ Error saving show: \(error.localizedDescription)")
            } else {
                print("✅ Show, Support Acts, and Itinerary Items saved successfully.")
                self.onSave()
                self.dismiss()
            }
        }
    }
    
    private func createItineraryItems(for show: Show, batch: WriteBatch) {
        guard let showId = show.id else { return }
        let db = Firestore.firestore()

        func createItineraryItem(forDate date: Timestamp?, type: ItineraryItemType, title: String) {
            guard let date = date else { return }
            let item = ItineraryItem(tourId: self.tourID, showId: showId, title: title, type: type.rawValue, timeUTC: date)
            let itemRef = db.collection("itineraryItems").document()
            try? batch.setData(from: item, forDocument: itemRef)
        }
        
        createItineraryItem(forDate: show.loadIn, type: .loadIn, title: "Load In")
        createItineraryItem(forDate: show.soundCheck, type: .soundcheck, title: "Soundcheck")
        createItineraryItem(forDate: show.doorsOpen, type: .doors, title: "Doors Open")
        createItineraryItem(forDate: show.headlinerSetTime, type: .headline, title: "\(self.artistName) Set")
        
        for sa in supportActs.filter({ !$0.name.isEmpty }) {
            createItineraryItem(forDate: Timestamp(date: createFullDate(for: sa.soundCheck)), type: .soundcheck, title: "\(sa.name) Soundcheck")
            createItineraryItem(forDate: Timestamp(date: createFullDate(for: sa.setTime)), type: .custom, title: "\(sa.name) Set")
        }
    }

    private static func defaultTime(hour: Int) -> Date {
        var components = Calendar.current.dateComponents([.year, .month, .day], from: Date())
        components.hour = hour
        components.minute = 0
        return Calendar.current.date(from: components) ?? Date()
    }
}
import SwiftUI
import FirebaseFirestore
import FirebaseAuth

struct MyAccountView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.colorScheme) private var systemColorScheme
    @State private var overrideColorScheme: ColorScheme? = nil
    @State private var isDarkMode: Bool = false
    @State private var totalTours: Int = 0
    @State private var totalShows: Int = 0
    @State private var totalFlights: Int = 0
    @State private var userEmail: String = ""

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 32) {
                accountInfoSection
                preferencesSection
                usageStatsSection
                supportSection
                devToolsSection
                versionSection
            }
            .padding()
            .onAppear {
                loadStats()
                loadUserEmail()
            }
        }
        .navigationTitle("My Account")
    }

    // MARK: - Account Info

    private var accountInfoSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Account")
                .font(.title2.bold())

            HStack(alignment: .center) {
                Image(systemName: "person.crop.circle.fill")
                    .font(.system(size: 60))
                    .foregroundColor(.blue)

                VStack(alignment: .leading, spacing: 4) {
                    if !userEmail.isEmpty {
                        Text(userEmail)
                            .font(.headline)
                    }

                    Text("User ID: \(appState.userID ?? "Unknown")")
                        .font(.subheadline)
                        .foregroundColor(.gray)

                    Text("Online Status: \(OfflineSyncManager.shared.isOnline ? "Online" : "Offline")")
                        .font(.subheadline)
                        .foregroundColor(OfflineSyncManager.shared.isOnline ? .green : .gray)
                }

                Spacer()

                Button("Sign Out", role: .destructive) {
                    signOut()
                }
                .font(.headline)
                .foregroundColor(.red)
                .buttonStyle(PlainButtonStyle())
            }
            .padding(.top, 8)
        }
    }

    // MARK: - Preferences

    private var preferencesSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Preferences")
                .font(.title2.bold())

            Toggle("Dark Mode", isOn: $isDarkMode)
                .onChange(of: isDarkMode) { value in
                    overrideColorScheme = value ? .dark : .light
                }
        }
    }

    // MARK: - Usage Stats

    private var usageStatsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Usage Stats")
                .font(.title2.bold())

            HStack {
                statBlock(label: "Tours", count: totalTours)
                statBlock(label: "Shows", count: totalShows)
                statBlock(label: "Flights", count: totalFlights)
            }
        }
    }

    private func statBlock(label: String, count: Int) -> some View {
        VStack {
            Text("\(count)")
                .font(.title)
                .bold()
            Text(label)
                .font(.subheadline)
                .foregroundColor(.gray)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }

    // MARK: - Support

    private var supportSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Support")
                .font(.title2.bold())

            Button("Contact Support") { }
            Button("Privacy Policy") { }
            Button("Terms of Service") { }
        }
    }

    // MARK: - Dev Tools

    private var devToolsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Developer Tools")
                .font(.title2.bold())

            Button(role: .destructive) {
                // Add wipe cache logic here
            } label: {
                Text("Wipe Local Cache")
            }
        }
    }

    // MARK: - Version

    private var versionSection: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text("App Version: 1.8.4") // This can be updated as needed
                .font(.footnote)
                .foregroundColor(.gray)
        }
    }

    // MARK: - Load Stats Logic

    private func loadStats() {
        guard let userID = appState.userID else { return }

        let db = Firestore.firestore()
        db.collection("users").document(userID).collection("tours").getDocuments { snapshot, _ in
            self.totalTours = snapshot?.documents.count ?? 0

            var showCount = 0
            var flightCount = 0

            let group = DispatchGroup()

            snapshot?.documents.forEach { tourDoc in
                group.enter()
                db.collection("users").document(userID).collection("tours").document(tourDoc.documentID).collection("shows").getDocuments { showSnapshot, _ in
                    showCount += showSnapshot?.documents.count ?? 0
                    group.leave()
                }

                group.enter()
                db.collection("users").document(userID).collection("tours").document(tourDoc.documentID).collection("flights").getDocuments { flightSnapshot, _ in
                    flightCount += flightSnapshot?.documents.count ?? 0
                    group.leave()
                }
            }

            group.notify(queue: .main) {
                self.totalShows = showCount
                self.totalFlights = flightCount
            }
        }
    }

    // MARK: - Load User Email

    private func loadUserEmail() {
        if let currentUser = Auth.auth().currentUser {
            self.userEmail = currentUser.email ?? ""
        }
    }

    // MARK: - Sign Out Logic

    private func signOut() {
        // FIXED: This now correctly calls the shared AuthManager to perform a full sign-out from Firebase.
        AuthManager.shared.signOut()
    }
}
import SwiftUI
import FirebaseFirestore

struct AddFlightView: View {
    var tour: Tour
    var onFlightAdded: () -> Void

    @Environment(\.dismiss) var dismiss
    @Environment(\.colorScheme) var colorScheme

    // Form State
    @State private var flightNumber = ""
    @State private var flightDate = Date() // This is the date the user selects
    @State private var selectedAirport: AirportEntry? = nil
    @State private var airportSearchText = ""
    @State private var notes = ""

    // View State
    @State private var isLoading = false
    @State private var fetchedFlight: Flight? = nil
    @State private var errorMessage: String? = nil

    // Passenger State
    @State private var crewSearchText = ""
    @State private var selectedPassengers: [String] = []
    @State private var baggageInput = ""
    @State private var crewSuggestions: [TourCrew] = []

    private let airports = AirportService.shared.airports

    private var filteredAirports: [AirportEntry] {
        if airportSearchText.isEmpty { return [] }
        return airports.filter {
            $0.name.lowercased().contains(airportSearchText.lowercased()) ||
            $0.city.lowercased().contains(airportSearchText.lowercased()) ||
            $0.iata.lowercased().contains(airportSearchText.lowercased())
        }
    }
    
    private var filteredCrew: [TourCrew] {
        if crewSearchText.isEmpty { return [] }
        return crewSuggestions.filter {
            $0.name.lowercased().contains(crewSearchText.lowercased()) &&
            !selectedPassengers.contains($0.id ?? "")
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 24) {
            HStack {
                Text("Add Flight").font(.title.bold())
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.gray)
                }
                .buttonStyle(.plain)
            }

            VStack(alignment: .leading, spacing: 16) {
                HStack(spacing: 16) {
                    VStack(alignment: .leading) {
                        Text("Flight Number").font(.subheadline)
                        TextField("e.g. QF140", text: $flightNumber)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                    }

                    VStack(alignment: .leading) {
                        Text("Flight Date").font(.subheadline)
                        DatePicker("", selection: $flightDate, displayedComponents: .date)
                            .labelsHidden()
                    }
                }

                VStack(alignment: .leading, spacing: 12) {
                    Text("Departure Airport").font(.subheadline)
                    TextField("Start typing airport...", text: $airportSearchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())

                    if !filteredAirports.isEmpty {
                        ScrollView {
                            VStack(alignment: .leading, spacing: 0) {
                                ForEach(filteredAirports) { airport in
                                    Button {
                                        selectAirport(airport)
                                    } label: {
                                        HStack {
                                            Text("\(airport.name) (\(airport.iata))")
                                            Spacer()
                                        }
                                        .padding(8)
                                    }
                                    .buttonStyle(.plain)
                                }
                            }
                        }
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                        .frame(maxHeight: 200)
                    }

                    if let selected = selectedAirport {
                        Text("Selected: \(selected.name)").font(.caption).foregroundColor(.gray)
                    }
                }
            }
            
            VStack(alignment: .leading, spacing: 16) {
                Text("Who's on this flight?").font(.headline)
                HStack {
                    VStack(alignment: .leading) {
                        Text("Name").font(.subheadline)
                        TextField("Search Crew", text: $crewSearchText)
                            .textFieldStyle(RoundedBorderTextFieldStyle())

                        if !filteredCrew.isEmpty {
                            ScrollView {
                                VStack(alignment: .leading, spacing: 0) {
                                    ForEach(filteredCrew) { crew in
                                        Button {
                                            crewSearchText = crew.name
                                        } label: {
                                            HStack {
                                                Text(crew.name)
                                                Spacer()
                                            }
                                            .padding(8)
                                        }
                                        .buttonStyle(.plain)
                                    }
                                }
                            }
                            .background(Color.gray.opacity(0.1))
                            .cornerRadius(8)
                            .frame(maxHeight: 150)
                        }
                    }

                    VStack(alignment: .leading) {
                        Text("Total Baggage (kg)").font(.subheadline)
                        TextField("kg", text: $baggageInput)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                    }
                }

                Button(action: { addPassenger() }) {
                    Text("+ Add Passenger")
                }
                .buttonStyle(.bordered)

                if !selectedPassengers.isEmpty {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("\(selectedPassengers.count) passenger(s) added.")
                    }
                }
            }

            if isLoading { ProgressView() }

            if let fetched = fetchedFlight {
                flightPreview(fetched)
                Button("Confirm & Add") {
                    saveFlight(fetched)
                }
                .buttonStyle(.borderedProminent)
            } else {
                Button(action: { fetchFlightData() }) {
                    Text("Search Flight")
                        .frame(maxWidth: .infinity).padding().background(Color.blue).foregroundColor(.white).cornerRadius(10)
                }
                .buttonStyle(.plain)
                .disabled(flightNumber.isEmpty || selectedAirport == nil)
            }

            if let error = errorMessage {
                Text(error).foregroundColor(.red)
            }

            Spacer()
        }
        .padding()
        .onAppear {
            // loadCrew() // This will be refactored later
        }
    }
    
    private func selectAirport(_ airport: AirportEntry) {
        selectedAirport = airport
        airportSearchText = "\(airport.name) (\(airport.iata))"
    }

    private func addPassenger() {
        guard let crewMember = crewSuggestions.first(where: { $0.name == crewSearchText }), let crewID = crewMember.id else { return }
        if !selectedPassengers.contains(crewID) {
            selectedPassengers.append(crewID)
        }
        crewSearchText = ""
        baggageInput = ""
    }

    private func flightPreview(_ flight: Flight) -> some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("\(flight.airline ?? "N/A") \(flight.flightNumber ?? "N/A")").font(.headline)
                Spacer()
            }
            Text("\(flight.origin) → \(flight.destination)").font(.subheadline)
            Text("Departs: \(flight.departureTimeUTC.dateValue().formatted(date: .long, time: .shortened))").font(.caption)
        }
        .padding()
        .background(Color(nsColor: .controlBackgroundColor))
        .cornerRadius(12)
    }
    
    private func loadCrew() {
        // This function will be refactored when we address the Crew feature.
    }

    // --- FIX IS HERE ---
    private func fetchFlightData() {
        guard let selectedAirport = selectedAirport, let tourID = tour.id else {
            self.errorMessage = "Please select a departure airport."
            return
        }

        isLoading = true
        errorMessage = nil

        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        let formattedDate = formatter.string(from: flightDate)

        FlightLabsAPI.fetchFutureFlights(depIATA: selectedAirport.iata, date: formattedDate) { result in
            DispatchQueue.main.async {
                self.isLoading = false
                switch result {
                case .success(let flights):
                    let airlineCode = String(self.flightNumber.prefix { $0.isLetter })
                    let number = String(self.flightNumber.drop { $0.isLetter })

                    if let match = flights.first(where: { $0.carrier.fs.uppercased() == airlineCode.uppercased() && $0.carrier.flightNumber == number }) {
                        
                        // This new helper function ensures the correct date is combined with the time from the API.
                        func createFullDate(from timeString24: String, on selectedDate: Date) -> Date {
                            let calendar = Calendar.current
                            let timeComponents = timeString24.split(separator: ":")
                            let hour = Int(timeComponents.first ?? "0") ?? 0
                            let minute = Int(timeComponents.last ?? "0") ?? 0
                            
                            return calendar.date(bySettingHour: hour, minute: minute, second: 0, of: selectedDate) ?? selectedDate
                        }

                        // Use the user's selected date as the base for both departure and arrival.
                        var departureDate = createFullDate(from: match.departureTime?.time24 ?? "00:00", on: self.flightDate)
                        var arrivalDate = createFullDate(from: match.arrivalTime?.time24 ?? "00:00", on: self.flightDate)
                        
                        // Handle overnight flights where arrival is on the next day
                        if arrivalDate < departureDate {
                            arrivalDate = Calendar.current.date(byAdding: .day, value: 1, to: arrivalDate) ?? arrivalDate
                        }
                        
                        let flight = Flight(
                            id: UUID().uuidString,
                            tourId: tourID,
                            airline: match.carrier.name,
                            flightNumber: "\(match.carrier.fs)\(match.carrier.flightNumber)",
                            departureTimeUTC: Timestamp(date: departureDate),
                            arrivalTimeUTC: Timestamp(date: arrivalDate),
                            origin: selectedAirport.iata,
                            destination: match.airport.fs,
                            notes: self.notes,
                            passengers: self.selectedPassengers
                        )
                        self.fetchedFlight = flight
                    } else {
                        self.errorMessage = "No matching flight found for this date."
                    }
                case .failure(let error):
                    self.errorMessage = error.localizedDescription
                }
            }
        }
    }

    private func saveFlight(_ flight: Flight) {
        let db = Firestore.firestore()
        
        do {
            // Save the Flight document
            let flightRef = try db.collection("flights").addDocument(from: flight)
            
            // Create and save the corresponding ItineraryItem document
            let itineraryItem = ItineraryItem(
                id: "flight-\(flightRef.documentID)", // Create a unique but related ID
                tourId: flight.tourId,
                showId: nil,
                title: "\(flight.airline ?? "") \(flight.flightNumber ?? ""): \(flight.origin) → \(flight.destination)",
                type: ItineraryItemType.flight.rawValue,
                timeUTC: flight.departureTimeUTC,
                notes: flight.notes
            )
            try db.collection("itineraryItems").document(itineraryItem.id!).setData(from: itineraryItem)
            
            self.onFlightAdded()
            self.dismiss()
            
        } catch {
            print("❌ Error saving flight and itinerary item: \(error.localizedDescription)")
            self.errorMessage = "Failed to save flight. Please try again."
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct ContentView: View {
    @State private var message = "Press the button to test Firebase."

    var body: some View {
        VStack(spacing: 20) {
            Text("Encore Admin App")
                .font(.title)
                .bold()

            Text(message)
                .foregroundColor(.gray)

            Button("Write Test Tour to Firebase") {
                let db = Firestore.firestore()
                db.collection("tours").addDocument(data: [
                    "name": "Test Tour",
                    "startDate": Date(),
                    "createdBy": "admin"
                ]) { error in
                    if let error = error {
                        message = "❌ Error: \(error.localizedDescription)"
                    } else {
                        message = "✅ Success! Test tour added."
                    }
                }
            }
        }
        .padding()
        .frame(minWidth: 400, minHeight: 300)
    }
}
import SwiftUI
import FirebaseFirestore

struct DBAddContactView: View {
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject var appState: AppState

    @State private var newContact: Contact
    @State private var isSaving = false
    
    var onContactAdded: () -> Void
    
    init(onContactAdded: @escaping () -> Void) {
        self.onContactAdded = onContactAdded
        // Initialize with a blank contact model for the form.
        // The ownerId will be replaced with the real one upon saving.
        self._newContact = State(initialValue: Contact(ownerId: "", name: "", roles: []))
    }

    private var isFormValid: Bool {
        !newContact.name.trimmingCharacters(in: .whitespaces).isEmpty &&
        !newContact.roles.isEmpty
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header
            HStack {
                Text("Add New Contact")
                    .font(.largeTitle.bold())
                Spacer()
                Button(action: { dismiss() }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title)
                        .foregroundColor(.gray.opacity(0.5))
                }
                .buttonStyle(.plain)
            }
            .padding([.top, .horizontal], 32)
            .padding(.bottom, 16)
            
            // This now correctly passes a binding to the new Contact model.
            ContactFormBody(contact: $newContact, isDisabled: false)
            
            Spacer()
            
            // Footer with Save Button
            HStack {
                Spacer()
                Button(action: saveContact) {
                    HStack {
                        if isSaving {
                            ProgressView().colorInvert()
                        } else {
                            Text("Save Contact")
                        }
                    }
                    .fontWeight(.semibold)
                    .frame(width: 200)
                    .padding()
                    .background(isFormValid ? Color.accentColor : Color.gray.opacity(0.5))
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .buttonStyle(.plain)
                .disabled(!isFormValid || isSaving)
                Spacer()
            }
            .padding(.vertical)
        }
        .frame(minWidth: 700, minHeight: 800)
        .background(Color(red: 28/255, green: 28/255, blue: 30/255))
    }
    
    // --- FIX IS HERE ---
    private func saveContact() {
        guard let userID = appState.userID else {
            print("Error: User ID is nil. Cannot save contact.")
            return
        }
        
        guard isFormValid else { return }
        
        isSaving = true
        
        // Create a new, final Contact object with the correct ownerId from the AppState.
        // This respects the 'let' constant nature of the property.
        let contactToSave = Contact(
            ownerId: userID,
            name: newContact.name,
            roles: newContact.roles,
            email: newContact.email,
            phone: newContact.phone,
            notes: newContact.notes,
            location: newContact.location,
            profileImageURL: newContact.profileImageURL,
            dateOfBirth: newContact.dateOfBirth,
            countryOfBirth: newContact.countryOfBirth,
            passport: newContact.passport,
            documents: newContact.documents,
            emergencyContact: newContact.emergencyContact,
            allergies: newContact.allergies,
            medications: newContact.medications
            // createdAt is handled by @ServerTimestamp in the model
        )
        
        let db = Firestore.firestore()
        
        do {
            // Use Codable to save the new object directly to the top-level /contacts collection
            try db.collection("contacts").addDocument(from: contactToSave) { error in
                self.isSaving = false
                if let error = error {
                    print("Error saving contact: \(error.localizedDescription)")
                } else {
                    print("✅ Contact saved successfully.")
                    self.onContactAdded()
                    self.dismiss()
                }
            }
        } catch {
            print("❌ Error encoding contact for save: \(error.localizedDescription)")
            self.isSaving = false
        }
    }
}
import SwiftUI

struct DatabaseView: View {
    let userID: String

    enum SectionType: String, CaseIterable {
        case contacts = "Contacts"
        case venues = "Venues"
        case hotels = "Hotels"
    }

    private enum ActiveSheet: Identifiable {
        case addContact, addVenue, addHotel
        var id: Int { hashValue }
    }

    @State private var selectedSection: SectionType = .contacts
    @State private var searchText: String = ""
    @State private var selectedFilter: String = "All"
    @State private var sortField: String = ""
    @State private var sortAscending: Bool = true
    @State private var activeSheet: ActiveSheet?
    // State to force a refresh of the contacts list
    @State private var contactsKey = UUID()

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            headerAndActions
            searchAndFilterBar
            Divider()
            sectionContent
        }
        .padding()
        .sheet(item: $activeSheet) { sheet in
            switch sheet {
            case .addContact:
                // FIXED: Correctly pass the onContactAdded closure to the initializer.
                ContactAddView {
                    self.contactsKey = UUID()
                }
            case .addVenue:
                DBAddVenueView()
            case .addHotel:
                DBAddHotelView()
            }
        }
    }

    private var headerAndActions: some View {
        HStack(alignment: .center) {
            HStack(spacing: 24) {
                ForEach(SectionType.allCases, id: \.self) { section in
                    Button(action: { selectedSection = section }) {
                        Text(section.rawValue)
                            .font(.largeTitle.bold())
                            .foregroundColor(selectedSection == section ? .primary : .gray)
                    }
                    .buttonStyle(.plain)
                }
            }
            .padding(.bottom, 10)
            
            Spacer()
            
            Button(action: {
                switch selectedSection {
                case .contacts: activeSheet = .addContact
                case .venues: activeSheet = .addVenue
                case .hotels: activeSheet = .addHotel
                }
            }) {
                Image(systemName: "plus.circle.fill")
                    .font(.title)
                    .foregroundColor(.accentColor)
            }
            .buttonStyle(.plain)
            .padding(.bottom, 10)
        }
    }

    private var searchAndFilterBar: some View {
        HStack {
            StyledInputField(placeholder: "Search...", text: $searchText)
                .frame(width: 300)
            Spacer()
            Text("Filter").foregroundColor(.gray)
            Picker("", selection: $selectedFilter) {
                ForEach(currentFilters(), id: \.self) { filter in
                    Text(filter).tag(filter)
                }
            }
            .pickerStyle(.segmented)
            .frame(width: 400)
        }
    }

    @ViewBuilder
    private var sectionContent: some View {
        switch selectedSection {
        case .contacts:
            ContactsSection(userID: userID, searchText: searchText, selectedFilter: selectedFilter, sortField: $sortField, sortAscending: $sortAscending)
                .id(contactsKey) // This makes the view refresh when the key changes.
        case .venues:
            VenuesSection(userID: userID, searchText: searchText, selectedFilter: selectedFilter, sortField: $sortField, sortAscending: $sortAscending)
        case .hotels:
            HotelsSection(userID: userID, searchText: searchText, selectedFilter: selectedFilter, sortField: $sortField, sortAscending: $sortAscending)
        }
    }

    private func currentFilters() -> [String] {
        switch selectedSection {
        case .contacts: return ContactFilter.allCases.map { $0.displayName }
        case .venues: return VenueFilter.allCases.map { $0.displayName }
        case .hotels: return HotelFilter.allCases.map { $0.displayName }
        }
    }
}
import SwiftUI
import FirebaseFirestore
import Kingfisher

struct TourListView: View {
    @EnvironmentObject var appState: AppState
    
    // FIX: The closure now uses the new 'Tour' model.
    var onTourSelected: ((Tour) -> Void)? = nil

    // FIX: These are now simple computed properties that filter the appState.tours array.
    // This removes the need for local state and redundant data fetching.
    private var upcomingTours: [Tour] {
        let today = Calendar.current.startOfDay(for: Date())
        return appState.tours.filter { $0.startDate.dateValue() > today }
    }

    private var currentTours: [Tour] {
        let today = Calendar.current.startOfDay(for: Date())
        return appState.tours.filter { $0.startDate.dateValue() <= today && $0.endDate.dateValue() >= today }
    }

    private var pastTours: [Tour] {
        let today = Calendar.current.startOfDay(for: Date())
        return appState.tours.filter { $0.endDate.dateValue() < today }.sorted { $0.endDate.dateValue() > $1.endDate.dateValue() }
    }

    var body: some View {
        // NOTE: The UI structure below is identical to your original file.
        ScrollView {
            VStack(alignment: .leading, spacing: 32) {

                if !upcomingTours.isEmpty {
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Upcoming")
                            .font(.title2.bold())
                            .padding(.horizontal)

                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 16) {
                                // The ForEach now iterates over the new computed property.
                                ForEach(upcomingTours) { tour in
                                    Button(action: {
                                        onTourSelected?(tour)
                                    }) {
                                        // TourCard was already fixed to accept the new 'Tour' model.
                                        TourCard(tour: tour)
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                }
                            }
                            .padding(.horizontal)
                        }
                    }
                }

                if !currentTours.isEmpty {
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Current Tours")
                            .font(.title2.bold())
                            .padding(.horizontal)

                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 16) {
                                ForEach(currentTours) { tour in
                                    Button(action: {
                                        onTourSelected?(tour)
                                    }) {
                                        TourCard(tour: tour)
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                }
                            }
                            .padding(.horizontal)
                        }
                    }
                }

                if !pastTours.isEmpty {
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Past Tours")
                            .font(.title2.bold())
                            .padding(.horizontal)

                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 16) {
                                ForEach(pastTours) { tour in
                                    Button(action: {
                                        onTourSelected?(tour)
                                    }) {
                                        TourCard(tour: tour)
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                }
                            }
                            .padding(.horizontal)
                        }
                    }
                }
            }
            .padding(.vertical)
        }
        .onAppear {
            // Instead of loading locally, we just tell the central AppState to load.
            // AppState will handle duplicates and updates for us.
            appState.loadTours()
            
            // The preloading logic is still a good idea.
            preloadPosterImages(for: appState.tours)
        }
    }

    // FIX: This function is now much simpler.
    private func preloadPosterImages(for tours: [Tour]) {
        let urls = tours.compactMap { URL(string: $0.posterURL ?? "") }
        ImagePrefetcher(urls: urls).start()
    }
}
import SwiftUI
import FirebaseFirestore

struct FlightCardView: View {
    // FIX: The view now accepts the complete, new 'Flight' model.
    let flight: Flight
    
    // We can determine dark mode from the flight data now.
    private var isDarkMode: Bool {
        (flight.airline ?? "").lowercased() == "air new zealand"
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            HStack {
                Text("\(flight.airline ?? "N/A") - \(flight.flightNumber ?? "----")")
                    .font(.caption)
                    .foregroundColor(.gray)
                Spacer()
                let airlineCode = extractAirlineCode(from: flight.flightNumber ?? "")
                // This assumes you have image assets named like "NZ_icon", "AA_icon", etc.
                Image("\(airlineCode)_icon")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 40, height: 40)
            }

            Text("\(flight.origin) → \(flight.destination)")
                .font(.title3).bold()
                .lineLimit(1)

            HStack(spacing: 12) {
                // FIX: These labels now call a helper to format the Timestamp directly.
                Label(formattedTime(from: flight.departureTimeUTC), systemImage: "airplane.departure")
                    .font(.caption)
                Label(formattedTime(from: flight.arrivalTimeUTC), systemImage: "airplane.arrival")
                    .font(.caption)
                
                // This calculates the duration between the two timestamps.
                Label(flightDuration(from: flight.departureTimeUTC, to: flight.arrivalTimeUTC), systemImage: "clock")
                    .font(.caption)
            }
        }
        .padding()
        .background(isDarkMode ? Color.black : Color.white)
        .cornerRadius(14)
    }

    /// Extracts the 2-letter airline code from a flight number.
    private func extractAirlineCode(from flightNumber: String) -> String {
        let prefix = flightNumber.prefix { $0.isLetter }
        return String(prefix)
    }

    /// Formats a Firestore Timestamp into a time string (e.g., "7:40 PM").
    private func formattedTime(from timestamp: Timestamp) -> String {
        let date = timestamp.dateValue()
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter.string(from: date)
    }

    /// Calculates and formats the duration between two Timestamps.
    private func flightDuration(from start: Timestamp, to end: Timestamp) -> String {
        let durationInSeconds = end.seconds - start.seconds
        let hours = durationInSeconds / 3600
        let minutes = (durationInSeconds % 3600) / 60
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct TourFlightsView: View {
    // FIX: The view now ONLY needs the tourID to fetch its data.
    // The unnecessary userID and ownerUserID have been removed.
    var tourID: String

    @State private var flights: [Flight] = []
    @State private var showAddFlight = false
    @State private var expandedFlightID: String? = nil
    @State private var flightListener: ListenerRegistration? = nil
    @EnvironmentObject var appState: AppState

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            SectionHeader(title: "Flights", onAdd: { showAddFlight = true })

            if flights.isEmpty {
                placeholderView
            } else {
                flightList
            }
        }
        .onAppear { setupListener() }
        .onDisappear { flightListener?.remove() }
        .sheet(isPresented: $showAddFlight) {
            // To present the AddFlightView, we find the full Tour object from appState.
            if let tour = appState.tours.first(where: { $0.id == tourID }) {
                AddFlightView(tour: tour, onFlightAdded: {})
            }
        }
    }

    private var placeholderView: some View {
        Text("No flights yet.")
            .frame(maxWidth: .infinity)
            .padding()
            .background(Color(nsColor: .controlBackgroundColor))
            .cornerRadius(12)
    }

    private var flightList: some View {
        VStack(spacing: 12) {
            ForEach(flights) { flight in
                FlightItemCard(
                    flight: flight,
                    isExpanded: expandedFlightID == flight.id,
                    onExpandToggle: { toggleExpanded(flight) },
                    onEdit: { /* Placeholder */ },
                    onDelete: { deleteFlight(flight) }
                )
                .animation(.easeInOut, value: expandedFlightID)
            }
        }
    }

    private func toggleExpanded(_ flight: Flight) {
        withAnimation {
            if expandedFlightID == flight.id {
                expandedFlightID = nil
            } else {
                expandedFlightID = flight.id
            }
        }
    }

    private func setupListener() {
        flightListener?.remove()
        flightListener = FirebaseFlightService.addFlightsListener(forTour: tourID) { loadedFlights in
            self.flights = loadedFlights.sorted(by: { $0.departureTimeUTC.dateValue() < $1.departureTimeUTC.dateValue() })
        }
    }

    private func deleteFlight(_ flight: Flight) {
        guard let flightID = flight.id else { return }
        FirebaseFlightService.deleteFlight(flightID: flightID) { error in
            if let error = error {
                print("Error deleting flight: \(error.localizedDescription)")
            }
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct VenueTableView: View {
    // FIX: The view now accepts an array of our new 'Venue' model.
    let venues: [Venue]
    @Binding var sortField: String
    @Binding var sortAscending: Bool

    var body: some View {
        ScrollView { // make the table scrollable
            VStack(alignment: .leading) {
                HStack {
                    SortableHeader(title: "Name", field: "Name", sortField: $sortField, sortAscending: $sortAscending)
                    SortableHeader(title: "City", field: "City", sortField: $sortField, sortAscending: $sortAscending)
                    SortableHeader(title: "Address", field: "Address", sortField: $sortField, sortAscending: $sortAscending)
                    SortableHeader(title: "Contact Name", field: "ContactName", sortField: $sortField, sortAscending: $sortAscending)
                    SortableHeader(title: "Contact Email", field: "ContactEmail", sortField: $sortField, sortAscending: $sortAscending)
                    SortableHeader(title: "Contact Phone", field: "ContactPhone", sortField: $sortField, sortAscending: $sortAscending)
                }
                .padding(.vertical, 8)

                Divider()

                // FIX: The ForEach now iterates correctly over the new [Venue] array.
                ForEach(sortedVenues) { venue in
                    HStack {
                        Text(venue.name).frame(maxWidth: .infinity, alignment: .leading)
                        Text(venue.city).frame(maxWidth: .infinity, alignment: .leading)
                        Text(venue.address ?? "").frame(maxWidth: .infinity, alignment: .leading)
                        Text(venue.contactName ?? "").frame(maxWidth: .infinity, alignment: .leading)
                        Text(venue.contactEmail ?? "").frame(maxWidth: .infinity, alignment: .leading)
                        Text(venue.contactPhone ?? "").frame(maxWidth: .infinity, alignment: .leading)
                    }
                    .padding(.vertical, 4)
                    Divider()
                }
            }
            .padding(.horizontal)
        }
    }

    // FIX: This computed property now sorts the new [Venue] array directly.
    private var sortedVenues: [Venue] {
        venues.sorted { a, b in
            let lhs = sortValue(for: a)
            let rhs = sortValue(for: b)
            return sortAscending ? lhs < rhs : lhs > rhs
        }
    }

    // FIX: This function now accepts the new 'Venue' model.
    private func sortValue(for venue: Venue) -> String {
        switch sortField {
        case "Name": return venue.name
        case "City": return venue.city
        case "Address": return venue.address ?? ""
        case "ContactName": return venue.contactName ?? ""
        case "ContactEmail": return venue.contactEmail ?? ""
        case "ContactPhone": return venue.contactPhone ?? ""
        default: return venue.name
        }
    }
}
import SwiftUI

struct StyledButtonV2: View {
    var title: String
    var action: () -> Void
    var fullWidth: Bool = false
    var showArrow: Bool = true
    var width: CGFloat? = nil

    var body: some View {
        Button(action: action) {
            HStack {
                Text(title)
                if showArrow {
                    Image(systemName: "arrow.right.circle.fill")
                }
                Spacer()
            }
            .padding()
            .frame(maxWidth: fullWidth ? .infinity : width)
            .background(Color(red: 238/255, green: 238/255, blue: 238/255))
            .foregroundColor(.black)
            .cornerRadius(12)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
import Foundation
import MapKit

class VenueSearchService: ObservableObject {
    @Published var results: [VenueResult] = []

    private var currentSearch: MKLocalSearch?

    func searchVenues(query: String) {
        currentSearch?.cancel()  // cancel previous search to avoid stacking

        guard !query.isEmpty else {
            self.results = []
            return
        }

        let request = MKLocalSearch.Request()
        request.naturalLanguageQuery = query
        request.resultTypes = [.address, .pointOfInterest]

        let search = MKLocalSearch(request: request)
        currentSearch = search

        search.start { [weak self] response, error in
            DispatchQueue.main.async {
                if let mapItems = response?.mapItems {
                    self?.results = mapItems.map {
                        VenueResult(
                            name: $0.name ?? "",
                            address: $0.placemark.title ?? "",
                            city: $0.placemark.locality ?? "",
                            country: $0.placemark.country ?? ""
                        )
                    }
                } else {
                    self?.results = []
                }
            }
        }
    }
}

struct VenueResult: Identifiable {
    let id = UUID()
    let name: String
    let address: String
    let city: String
    let country: String
}
import Foundation
import FirebaseFirestore

class FirebaseUserService {
    
    static let shared = FirebaseUserService()
    private let db = Firestore.firestore()
    
    /// Checks if a user document exists for a given email.
    /// - a `userID` string if found, otherwise `nil`.
    func checkUserExists(byEmail email: String, completion: @escaping (String?) -> Void) {
        // This query correctly checks the top-level /users collection.
        db.collection("users").whereField("email", isEqualTo: email).getDocuments { snapshot, error in
            if let doc = snapshot?.documents.first {
                // A user with this email exists, return their ID.
                completion(doc.documentID)
            } else {
                // No user found with this email.
                completion(nil)
            }
        }
    }
    
    // The shared tour function can remain, though it may need refactoring later.
    func addSharedTour(for userID: String, tourID: String, creatorUserID: String, role: [String], visibility: String) {
        let sharedTourRef = db.collection("users").document(userID).collection("sharedTours").document(tourID)
        let data: [String: Any] = [
            "creatorUserID": creatorUserID,
            "dateAdded": Date(),
            "roles": role,
            "visibility": visibility
        ]
        sharedTourRef.setData(data)
    }
}
import Foundation
import FirebaseFirestore

class SetlistService {
    static let shared = SetlistService()
    private let db = Firestore.firestore()

    // --- Setlist Item Functions ---

    func addListener(forShow showID: String, completion: @escaping ([SetlistItem]) -> Void) -> ListenerRegistration {
        // Query the top-level 'setlists' collection for items matching the showID.
        return db.collection("setlists")
            .whereField("showId", isEqualTo: showID)
            .order(by: "order")
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error fetching setlist items: \(error?.localizedDescription ?? "Unknown error")")
                    completion([])
                    return
                }
                // Use the power of Codable to automatically decode documents into our new SetlistItem struct.
                let items = documents.compactMap { try? $0.data(as: SetlistItem.self) }
                completion(items)
            }
    }

    func saveItem(_ item: SetlistItem) {
        // Save the item directly to the top-level 'setlists' collection.
        // We use the item's ID to create or update the document.
        guard let itemID = item.id else {
            // If the item is new and has no ID, Firestore will generate one.
            try? db.collection("setlists").addDocument(from: item)
            return
        }
        try? db.collection("setlists").document(itemID).setData(from: item, merge: true)
    }

    func deleteItem(_ itemID: String) {
        // Delete the item directly from the top-level 'setlists' collection.
        db.collection("setlists").document(itemID).delete()
    }
    
    func updateOrder(for items: [SetlistItem]) {
        let batch = db.batch()
        for item in items {
            if let itemID = item.id {
                let docRef = db.collection("setlists").document(itemID)
                batch.updateData(["order": item.order], forDocument: docRef)
            }
        }
        batch.commit()
    }

    // --- Personal Note Functions ---

    func addNotesListener(for itemID: String, completion: @escaping ([PersonalNote]) -> Void) -> ListenerRegistration {
        // Query the new top-level 'personalNotes' collection.
        return db.collection("personalNotes")
            .whereField("setlistItemId", isEqualTo: itemID)
            .order(by: "createdAt", descending: true)
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error fetching notes: \(error?.localizedDescription ?? "Unknown error")")
                    completion([])
                    return
                }
                let notes = documents.compactMap { try? $0.data(as: PersonalNote.self) }
                completion(notes)
            }
    }

    func saveNote(_ note: PersonalNote) {
        // Save the note directly to the top-level 'personalNotes' collection.
        guard let noteID = note.id else {
            try? db.collection("personalNotes").addDocument(from: note)
            return
        }
        try? db.collection("personalNotes").document(noteID).setData(from: note, merge: true)
    }
    
    func deleteNote(_ noteID: String) {
        // Delete the note directly from the top-level 'personalNotes' collection.
        db.collection("personalNotes").document(noteID).delete()
    }
}
import Foundation
import FirebaseFirestore

struct FirebaseTourService {
    static let db = Firestore.firestore()

    // FIX: Updated to fetch from the top-level /tourCrew collection.
    static func loadCrew(forTour tourID: String) async throws -> [TourCrew] {
        let snapshot = try await db.collection("tourCrew")
            .whereField("tourId", isEqualTo: tourID)
            .getDocuments()

        let crew = snapshot.documents.compactMap { try? $0.data(as: TourCrew.self) }
        return crew
    }
    
    // FIX: Updated to fetch from the top-level /shows collection.
    static func fetchShows(forTour tourID: String) async throws -> [Show] {
        let snapshot = try await db.collection("shows")
            .whereField("tourId", isEqualTo: tourID)
            .order(by: "date", descending: false)
            .getDocuments()
            
        let shows = snapshot.documents.compactMap { try? $0.data(as: Show.self) }
        return shows
    }
}
import Foundation

class AirportService {
    static let shared = AirportService()

    private(set) var airports: [AirportEntry] = []

    private init() {
        loadAirports()
    }

    private func loadAirports() {
        guard let url = Bundle.main.url(forResource: "airports", withExtension: "json"),
              let data = try? Data(contentsOf: url),
              let dict = try? JSONDecoder().decode(AirportDictionary.self, from: data) else {
            return
        }

        self.airports = dict.values.map {
            AirportEntry(
                name: "\($0.name) (\($0.iata))",
                iata: $0.iata,
                city: $0.city,
                country: $0.country
            )
        }.sorted { $0.name < $1.name }
    }
}
import Foundation
import FirebaseFirestore

struct FirebaseFlightService {
    static let db = Firestore.firestore()

    // NEW: Real-time listener function for the top-level /flights collection
    static func addFlightsListener(forTour tourID: String, completion: @escaping ([Flight]) -> Void) -> ListenerRegistration {
        return db.collection("flights")
            .whereField("tourId", isEqualTo: tourID)
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error fetching flight snapshots: \(error?.localizedDescription ?? "Unknown error")")
                    completion([])
                    return
                }
                // Automatically decode documents into our new 'Flight' model
                let flights = documents.compactMap { try? $0.data(as: Flight.self) }
                completion(flights)
            }
    }

    // NEW: Simplified save function using a Codable object
    static func saveFlight(_ flight: Flight, completion: @escaping (Error?) -> Void) {
        guard let flightID = flight.id else {
            // If the flight is new, Firestore will generate an ID.
            var tempFlight = flight
            // This ensures the written document will have an ID field if we need it later.
            // Firestore handles the actual DocumentID separately.
            tempFlight.id = UUID().uuidString
            do {
                _ = try db.collection("flights").addDocument(from: tempFlight, completion: completion)
            } catch {
                completion(error)
            }
            return
        }
        // If the flight already has an ID, we update it.
        try? db.collection("flights").document(flightID).setData(from: flight, merge: true, completion: completion)
    }

    // This function can be deprecated or updated if needed, but is no longer used by the listener approach.
    static func loadFlights(forTour tourID: String, completion: @escaping ([Flight]) -> Void) {
      db.collection("flights")
          .whereField("tourId", isEqualTo: tourID)
          .getDocuments { snapshot, error in
              guard let documents = snapshot?.documents else {
                  completion([])
                  return
              }
              let flights = documents.compactMap { try? $0.data(as: Flight.self) }
              completion(flights)
          }
    }
 
    static func deleteFlight(flightID: String, completion: @escaping (Error?) -> Void) {
        // Delete directly from the top-level collection
        db.collection("flights").document(flightID).delete { error in
            completion(error)
        }
    }
}
import Foundation

enum ItineraryItemType: String, Codable, CaseIterable {
    case loadIn
    case soundcheck
    case doors
    case packOut
    case flight
    case arrival
    case hotel
    case meeting
    case freeTime
    case catering
    case custom
    case headline
    case travel
    case content
    case merch
    
    var displayName: String {
        switch self {
        case .loadIn: return "Load In"
        case .soundcheck: return "Soundcheck"
        case .doors: return "Doors Open"
        case .packOut: return "Pack Out"
        case .flight: return "Flight"
        case .arrival: return "Arrival"
        case .hotel: return "Hotel"
        case .meeting: return "Meeting"
        case .freeTime: return "Free Time"
        case .catering: return "Catering"
        case .custom: return "Custom"
        case .headline: return "Headliner Set"
        case .travel: return "Travel"
        case .content: return "Content"
        case .merch: return "Merchandise"
        }
    }
    
    var iconName: String {
        switch self {
        case .loadIn: return "truck.box"
        case .soundcheck: return "music.mic"
        case .doors: return "door.left.hand.open"
        case .packOut: return "shippingbox"
        case .flight: return "airplane"
        case .arrival: return "airplane.arrival"
        case .hotel: return "bed.double.fill"
        case .meeting: return "person.2.fill"
        case .freeTime: return "clock.fill"
        case .catering: return "fork.knife"
        case .custom: return "calendar"
        case .headline: return "music.mic.circle.fill"
        case .travel: return "car.fill"
        case .content: return "camera.fill"
        case .merch: return "tshirt.fill"
        }
    }

    // FIX: This logic now lives inside the enum where it belongs.
    var isShowTiming: Bool {
        switch self {
        case .loadIn, .soundcheck, .doors, .headline, .packOut:
            return true
        default:
            return false
        }
    }

    // FIX: This now correctly maps the enum case to the Firestore field name.
    var firestoreShowKey: String? {
        switch self {
        case .loadIn: return "loadIn"
        case .soundcheck: return "soundCheck"
        case .doors: return "doorsOpen"
        case .headline: return "headlinerSetTime"
        case .packOut: return "packOut"
        default: return nil
        }
    }
}
import SwiftUI
import FirebaseFirestore

struct HotelsSection: View {
    let userID: String
    let searchText: String
    let selectedFilter: String
    @Binding var sortField: String
    @Binding var sortAscending: Bool

    // FIX: The state now uses our new, top-level 'Hotel' model.
    @State private var hotels: [Hotel] = []
    @State private var isLoading: Bool = true
    @State private var listener: ListenerRegistration?

    var body: some View {
        VStack {
            if isLoading {
                Spacer()
                ProgressView().progressViewStyle(.circular)
                Spacer()
            } else {
                // This will cause an error in HotelTableView next, which is expected.
                HotelTableView(hotels: filteredAndSorted(), sortField: $sortField, sortAscending: $sortAscending)
            }
        }
        .onAppear(perform: setupListener)
        .onDisappear { listener?.remove() }
    }

    // --- FIX IS HERE ---
    private func setupListener() {
        self.isLoading = true
        listener?.remove()
        
        let db = Firestore.firestore()
        
        // This is now ONE simple, real-time listener on the top-level /hotels collection.
        listener = db.collection("hotels")
            .whereField("ownerId", isEqualTo: userID)
            .addSnapshotListener { snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error loading hotels: \(error?.localizedDescription ?? "Unknown")")
                    self.isLoading = false
                    return
                }
                
                self.hotels = documents.compactMap { try? $0.data(as: Hotel.self) }
                self.isLoading = false
            }
    }

    private func filteredAndSorted() -> [Hotel] {
        let filtered = hotels.filter { hotel in
            let matchesFilter = selectedFilter == "All" || (hotel.city ?? "") == selectedFilter
            let matchesSearch = searchText.isEmpty || hotel.name.lowercased().contains(searchText.lowercased())
            return matchesFilter && matchesSearch
        }

        return filtered.sorted { lhs, rhs in
            let lhsValue = sortFieldValue(lhs)
            let rhsValue = sortFieldValue(rhs)
            return sortAscending ? lhsValue < rhsValue : lhsValue > rhsValue
        }
    }

    private func sortFieldValue(_ hotel: Hotel) -> String {
        switch sortField {
        case "City": return hotel.city ?? ""
        default: return hotel.name
        }
    }
}
import SwiftUI

struct SectionHeader: View {
    var title: String
    var onAdd: () -> Void

    var body: some View {
        HStack {
            Text(title).font(.headline)
            Spacer()
            Button(action: onAdd) {
                Image(systemName: "plus.circle")
            }
            .buttonStyle(.plain)
        }
    }
}
